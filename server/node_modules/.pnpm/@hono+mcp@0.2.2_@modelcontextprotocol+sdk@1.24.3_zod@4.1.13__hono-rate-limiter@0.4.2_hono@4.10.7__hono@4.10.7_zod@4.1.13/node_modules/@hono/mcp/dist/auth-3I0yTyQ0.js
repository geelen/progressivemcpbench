import { InvalidClientError, InvalidClientMetadataError, InvalidGrantError, InvalidRequestError, InvalidScopeError, OAuthError, ServerError, TooManyRequestsError, UnsupportedGrantTypeError } from "@modelcontextprotocol/sdk/server/auth/errors.js";
import { Hono } from "hono";
import { cors } from "hono/cors";
import * as z from "zod/v4";
import { OAuthClientInformationFullSchema, OAuthClientMetadataSchema, OAuthTokenRevocationRequestSchema, OAuthTokensSchema } from "@modelcontextprotocol/sdk/shared/auth.js";
import { verifyChallenge } from "pkce-challenge";
import { bearerAuth } from "hono/bearer-auth";

//#region src/auth/helpers/authorize.ts
const ClientAuthorizationParamsSchema = z.object({
	client_id: z.string(),
	redirect_uri: z.string().optional().refine((value) => value === void 0 || URL.canParse(value), { message: "redirect_uri must be a valid URL" })
});
const RequestAuthorizationParamsSchema = z.object({
	response_type: z.literal("code"),
	code_challenge: z.string(),
	code_challenge_method: z.literal("S256"),
	scope: z.string().optional(),
	state: z.string().optional(),
	resource: z.url().optional()
});
function authorizeHandler(provider) {
	return async (c) => {
		c.header("Cache-Control", "no-store");
		let redirect_uri, client;
		try {
			const result = ClientAuthorizationParamsSchema.safeParse(c.req.method === "POST" ? await c.req.json() : c.req.query());
			if (!result.success) throw new InvalidRequestError(result.error.message);
			redirect_uri = result.data.redirect_uri;
			client = await provider.clientsStore.getClient(result.data.client_id);
			if (!client) throw new InvalidClientError("Invalid client_id");
			if (redirect_uri !== void 0) {
				if (!client.redirect_uris.includes(redirect_uri)) throw new InvalidRequestError("Unregistered redirect_uri");
			} else if (client.redirect_uris.length === 1) redirect_uri = client.redirect_uris[0];
			else throw new InvalidRequestError("redirect_uri must be specified when client has multiple registered URIs");
		} catch (error) {
			if (error instanceof OAuthError) {
				const status = error instanceof ServerError ? 500 : 400;
				return c.json(error.toResponseObject(), status);
			}
			const serverError = new ServerError("Internal Server Error");
			return c.json(serverError.toResponseObject(), 500);
		}
		let state;
		try {
			const parseResult = RequestAuthorizationParamsSchema.safeParse(c.req.method === "POST" ? await c.req.json() : c.req.query());
			if (!parseResult.success) throw new InvalidRequestError(parseResult.error.message);
			const { scope, code_challenge, resource } = parseResult.data;
			state = parseResult.data.state;
			let requestedScopes = [];
			if (scope !== void 0) {
				requestedScopes = scope.split(" ");
				const allowedScopes = new Set(client.scope?.split(" "));
				for (const scope$1 of requestedScopes) if (!allowedScopes.has(scope$1)) throw new InvalidScopeError(`Client was not registered with scope ${scope$1}`);
			}
			await provider.authorize(client, {
				state,
				scopes: requestedScopes,
				redirectUri: redirect_uri,
				codeChallenge: code_challenge,
				resource: resource ? new URL(resource) : void 0
			}, c);
			return c.res;
		} catch (error) {
			if (error instanceof OAuthError) return c.redirect(createErrorRedirect(redirect_uri, error, state));
			const serverError = new ServerError("Internal Server Error");
			return c.redirect(createErrorRedirect(redirect_uri, serverError, state), 302);
		}
	};
}
/**
* Helper function to create redirect URL with error parameters
*/
function createErrorRedirect(redirectUri, error, state) {
	const errorUrl = new URL(redirectUri);
	errorUrl.searchParams.set("error", error.errorCode);
	errorUrl.searchParams.set("error_description", error.message);
	if (error.errorUri) errorUrl.searchParams.set("error_uri", error.errorUri);
	if (state) errorUrl.searchParams.set("state", state);
	return errorUrl.href;
}

//#endregion
//#region src/auth/helpers/register.ts
const DEFAULT_CLIENT_SECRET_EXPIRY_SECONDS = 720 * 60 * 60;
function clientRegistrationHandler({ clientsStore, clientSecretExpirySeconds = DEFAULT_CLIENT_SECRET_EXPIRY_SECONDS, clientIdGeneration = true }) {
	if (!clientsStore.registerClient) throw new Error("Client registration store does not support registering clients");
	return async (c) => {
		c.header("Cache-Control", "no-store");
		try {
			const parseResult = OAuthClientMetadataSchema.safeParse(await c.req.json());
			if (!parseResult.success) throw new InvalidClientMetadataError(parseResult.error.message);
			const clientMetadata = parseResult.data;
			const isPublicClient = clientMetadata.token_endpoint_auth_method === "none";
			const clientSecret = isPublicClient ? void 0 : genRanHex(64);
			const clientIdIssuedAt = Math.floor(Date.now() / 1e3);
			const secretExpiryTime = clientSecretExpirySeconds > 0 ? clientIdIssuedAt + clientSecretExpirySeconds : 0;
			const clientSecretExpiresAt = isPublicClient ? void 0 : secretExpiryTime;
			let clientInfo = {
				...clientMetadata,
				client_secret: clientSecret,
				client_secret_expires_at: clientSecretExpiresAt
			};
			if (clientIdGeneration) {
				clientInfo.client_id = crypto.randomUUID();
				clientInfo.client_id_issued_at = clientIdIssuedAt;
			}
			clientInfo = await clientsStore.registerClient(clientInfo);
			return c.json(clientInfo, 201);
		} catch (error) {
			if (error instanceof OAuthError) {
				const status = error instanceof ServerError ? 500 : 400;
				return c.json(error.toResponseObject(), status);
			} else {
				const serverError = new ServerError("Internal Server Error");
				return c.json(serverError.toResponseObject(), 500);
			}
		}
	};
}
const genRanHex = (size) => [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join("");

//#endregion
//#region src/auth/helpers/revoke.ts
function revokeHandler(provider) {
	if (!provider.revokeToken) throw new Error("Auth provider does not support revoking tokens");
	return async (c) => {
		c.header("Cache-Control", "no-store");
		try {
			const parseResult = OAuthTokenRevocationRequestSchema.safeParse(await c.req.json());
			if (!parseResult.success) throw new InvalidRequestError(parseResult.error.message);
			const client = c.get("client");
			if (!client) throw new ServerError("Internal Server Error");
			await provider.revokeToken(client, parseResult.data);
			return c.json({});
		} catch (error) {
			if (error instanceof OAuthError) {
				const status = error instanceof ServerError ? 500 : 400;
				return c.json(error.toResponseObject(), status);
			} else {
				const serverError = new ServerError("Internal Server Error");
				return c.json(serverError.toResponseObject(), 500);
			}
		}
	};
}

//#endregion
//#region src/auth/helpers/token.ts
const TokenRequestSchema = z.object({ grant_type: z.string() });
const AuthorizationCodeGrantSchema = z.object({
	code: z.string(),
	code_verifier: z.string(),
	redirect_uri: z.string().optional(),
	resource: z.url().optional()
});
const RefreshTokenGrantSchema = z.object({
	refresh_token: z.string(),
	scope: z.string().optional(),
	resource: z.url().optional()
});
function tokenHandler(provider) {
	return async (c) => {
		c.header("Cache-Control", "no-store");
		try {
			let body;
			if (c.req.header("Content-Type") === "application/json") body = await c.req.json();
			else body = await c.req.parseBody();
			const parseResult = TokenRequestSchema.safeParse(body);
			if (!parseResult.success) throw new InvalidRequestError(parseResult.error.message);
			const { grant_type } = parseResult.data;
			const client = c.get("client");
			if (!client) throw new ServerError("Internal Server Error");
			switch (grant_type) {
				case "authorization_code": {
					const parseResult$1 = AuthorizationCodeGrantSchema.safeParse(body);
					if (!parseResult$1.success) throw new InvalidRequestError(parseResult$1.error.message);
					const { code, code_verifier, redirect_uri, resource } = parseResult$1.data;
					const skipLocalPkceValidation = provider.skipLocalPkceValidation;
					if (!skipLocalPkceValidation) {
						if (!await verifyChallenge(code_verifier, await provider.challengeForAuthorizationCode(client, code))) throw new InvalidGrantError("code_verifier does not match the challenge");
					}
					const tokens = await provider.exchangeAuthorizationCode(client, code, skipLocalPkceValidation ? code_verifier : void 0, redirect_uri, resource ? new URL(resource) : void 0);
					return c.json(tokens, 200);
				}
				case "refresh_token": {
					const parseResult$1 = RefreshTokenGrantSchema.safeParse(body);
					if (!parseResult$1.success) throw new InvalidRequestError(parseResult$1.error.message);
					const { refresh_token, scope, resource } = parseResult$1.data;
					const scopes = scope?.split(" ");
					const tokens = await provider.exchangeRefreshToken(client, refresh_token, scopes, resource ? new URL(resource) : void 0);
					return c.json(tokens);
				}
				default: throw new UnsupportedGrantTypeError("The grant type is not supported by this authorization server.");
			}
		} catch (error) {
			if (error instanceof OAuthError) {
				const status = error instanceof ServerError ? 500 : 400;
				return c.json(error.toResponseObject(), status);
			}
			const serverError = new ServerError("Internal Server Error");
			return c.json(serverError.toResponseObject(), 500);
		}
	};
}

//#endregion
//#region src/auth/helpers/utils.ts
const checkIssuerUrl = (issuer) => {
	if (issuer.protocol !== "https:" && issuer.hostname !== "localhost" && issuer.hostname !== "127.0.0.1") throw new Error("Issuer URL must be HTTPS");
	if (issuer.hash) throw new Error(`Issuer URL must not have a fragment: ${issuer}`);
	if (issuer.search) throw new Error(`Issuer URL must not have a query string: ${issuer}`);
};

//#endregion
//#region src/auth/helpers/wellknown.ts
function wellKnownRouter(options) {
	checkIssuerUrl(new URL(options.oauthMetadata.issuer));
	const router = new Hono().basePath("/.well-known");
	const protectedResourceMetadata = {
		resource: options.resourceServerUrl.href,
		authorization_servers: [options.oauthMetadata.issuer],
		scopes_supported: options.scopesSupported,
		resource_name: options.resourceName,
		resource_documentation: options.serviceDocumentationUrl?.href
	};
	const rsPath = new URL(options.resourceServerUrl.href).pathname;
	router.get(`/oauth-protected-resource${rsPath === "/" ? "" : rsPath}`, (c) => c.json(protectedResourceMetadata));
	router.get("/oauth-authorization-server", (c) => c.json(options.oauthMetadata));
	return router;
}

//#endregion
//#region src/auth/middleware/client-auth.ts
const ClientAuthenticatedRequestSchema = z.object({
	client_id: z.string(),
	client_secret: z.string().optional()
});
function authenticateClient({ clientsStore }) {
	return async (c, next) => {
		try {
			let body;
			if (c.req.header("Content-Type") === "application/json") body = await c.req.json();
			else body = await c.req.parseBody();
			const result = ClientAuthenticatedRequestSchema.safeParse(body);
			if (!result.success) throw new InvalidRequestError(String(result.error));
			const { client_id, client_secret } = result.data;
			const client = await clientsStore.getClient(client_id);
			if (!client) throw new InvalidClientError("Invalid client_id");
			if (client.client_secret) {
				if (!client_secret) throw new InvalidClientError("Client secret is required");
				if (client.client_secret !== client_secret) throw new InvalidClientError("Invalid client_secret");
				if (client.client_secret_expires_at && client.client_secret_expires_at < Math.floor(Date.now() / 1e3)) throw new InvalidClientError("Client secret has expired");
			}
			c.set("client", client);
			await next();
		} catch (error) {
			if (error instanceof OAuthError) {
				const status = error instanceof ServerError ? 500 : 400;
				return c.json(error.toResponseObject(), status);
			}
			const serverError = new ServerError("Internal Server Error");
			return c.json(serverError.toResponseObject(), 500);
		}
	};
}

//#endregion
//#region src/auth/router.ts
const createOAuthMetadata = (options) => {
	const issuer = options.issuerUrl;
	const baseUrl = options.baseUrl;
	checkIssuerUrl(issuer);
	const authorization_endpoint = "/authorize";
	const token_endpoint = "/token";
	const registration_endpoint = options.provider?.clientsStore.registerClient ? "/register" : void 0;
	const revocation_endpoint = options.provider?.revokeToken ? "/revoke" : void 0;
	return {
		issuer: issuer.href,
		service_documentation: options.serviceDocumentationUrl?.href,
		authorization_endpoint: new URL(authorization_endpoint, baseUrl || issuer).href,
		response_types_supported: ["code"],
		code_challenge_methods_supported: ["S256"],
		token_endpoint: new URL(token_endpoint, baseUrl || issuer).href,
		token_endpoint_auth_methods_supported: ["client_secret_post"],
		grant_types_supported: ["authorization_code", "refresh_token"],
		scopes_supported: options.scopesSupported,
		revocation_endpoint: revocation_endpoint ? new URL(revocation_endpoint, baseUrl || issuer).href : void 0,
		revocation_endpoint_auth_methods_supported: revocation_endpoint ? ["client_secret_post"] : void 0,
		registration_endpoint: registration_endpoint ? new URL(registration_endpoint, baseUrl || issuer).href : void 0
	};
};
/**
* Installs standard MCP authorization server endpoints, including dynamic client registration and token revocation (if supported).
* Also advertises standard authorization server metadata, for easier discovery of supported configurations by clients.
* Note: if your MCP server is only a resource server and not an authorization server, use mcpAuthMetadataRouter instead.
*
* By default, rate limiting is applied to all endpoints to prevent abuse.
*
* This router MUST be installed at the application root, like so:
*
*  const app = new Hono();
*  app.route("/", mcpAuthRouter(...));
*/
function mcpAuthRouter(options) {
	const oauthMetadata = createOAuthMetadata(options);
	const router = new Hono().use(cors());
	router.on(["GET", "POST"], new URL(oauthMetadata.authorization_endpoint).pathname, applyRateLimiter(options.authorizationOptions?.rateLimit, {
		windowMs: 900 * 1e3,
		limit: 100,
		standardHeaders: true,
		keyGenerator: () => "some-unique-key",
		message: new TooManyRequestsError("You have exceeded the rate limit for token requests").toResponseObject()
	}), authorizeHandler(options.provider));
	const authenticateClientMiddleware = authenticateClient({ clientsStore: options.provider.clientsStore });
	router.post(new URL(oauthMetadata.token_endpoint).pathname, applyRateLimiter(options.tokenOptions?.rateLimit, {
		windowMs: 900 * 1e3,
		limit: 50,
		standardHeaders: true,
		keyGenerator: () => "some-unique-key",
		message: new TooManyRequestsError("You have exceeded the rate limit for token requests").toResponseObject()
	}), authenticateClientMiddleware, tokenHandler(options.provider));
	router.route("/", wellKnownRouter({
		oauthMetadata,
		resourceServerUrl: options.resourceServerUrl ?? options.baseUrl ?? new URL(oauthMetadata.issuer),
		serviceDocumentationUrl: options.serviceDocumentationUrl,
		scopesSupported: options.scopesSupported,
		resourceName: options.resourceName
	}));
	if (oauthMetadata.registration_endpoint) router.post(new URL(oauthMetadata.registration_endpoint).pathname, applyRateLimiter(options.clientRegistrationOptions?.rateLimit, {
		windowMs: 3600 * 1e3,
		limit: 20,
		standardHeaders: true,
		keyGenerator: () => "some-unique-key",
		message: new TooManyRequestsError("You have exceeded the rate limit for client registration requests").toResponseObject()
	}), clientRegistrationHandler({
		clientsStore: options.provider.clientsStore,
		clientIdGeneration: options.clientRegistrationOptions?.clientIdGeneration,
		clientSecretExpirySeconds: options.clientRegistrationOptions?.clientSecretExpirySeconds
	}));
	if (oauthMetadata.revocation_endpoint) router.post(new URL(oauthMetadata.revocation_endpoint).pathname, applyRateLimiter(options.revocationOptions?.rateLimit, {
		windowMs: 900 * 1e3,
		limit: 50,
		standardHeaders: true,
		keyGenerator: () => "some-unique-key",
		message: new TooManyRequestsError("You have exceeded the rate limit for token revocation requests").toResponseObject()
	}), authenticateClientMiddleware, revokeHandler(options.provider));
	return router;
}
function applyRateLimiter(options, defaultOptions) {
	if (options === false) return (_c, next) => next();
	return async (c, next) => {
		try {
			return await (await import("hono-rate-limiter").then((m) => m.rateLimiter))({
				...defaultOptions,
				...options
			})(c, next);
		} catch {
			throw new Error("@hono/mcp: Missing dependencies \"hono-rate-limiter\".");
		}
	};
}

//#endregion
//#region src/auth/middleware/bearerAuth.ts
const bearerAuth$1 = (options) => bearerAuth({
	noAuthenticationHeader: { wwwAuthenticateHeader: (c) => `Bearer error="Unauthorized", error_description="Unauthorized", resource_metadata="${new URL(c.req.url).origin}/.well-known/oauth-protected-resource"` },
	invalidAuthenticationHeader: { wwwAuthenticateHeader: (c) => `Bearer error="Unauthorized", error_description="Unauthorized", resource_metadata="${new URL(c.req.url).origin}/.well-known/oauth-protected-resource"` },
	...options
});

//#endregion
//#region src/auth/providers/proxy-provider.ts
/**
* Implements an OAuth server that proxies requests to another OAuth server.
*/
var ProxyOAuthServerProvider = class {
	_endpoints;
	_verifyAccessToken;
	_getClient;
	_fetch;
	skipLocalPkceValidation = true;
	revokeToken;
	constructor(options) {
		this._endpoints = options.endpoints;
		this._verifyAccessToken = options.verifyAccessToken;
		this._getClient = options.getClient;
		this._fetch = options.fetch;
		if (options.endpoints?.revocationUrl) this.revokeToken = async (client, request) => {
			const revocationUrl = this._endpoints.revocationUrl;
			if (!revocationUrl) throw new Error("No revocation endpoint configured");
			const params = new URLSearchParams();
			params.set("token", request.token);
			params.set("client_id", client.client_id);
			if (client.client_secret) params.set("client_secret", client.client_secret);
			if (request.token_type_hint) params.set("token_type_hint", request.token_type_hint);
			const response = await (this._fetch ?? fetch)(revocationUrl, {
				method: "POST",
				headers: { "Content-Type": "application/x-www-form-urlencoded" },
				body: params.toString()
			});
			if (!response.ok) throw new ServerError(`Token revocation failed: ${response.status}`);
		};
	}
	get clientsStore() {
		const registrationUrl = this._endpoints.registrationUrl;
		return {
			getClient: this._getClient,
			...registrationUrl && { registerClient: async (client) => {
				const response = await (this._fetch ?? fetch)(registrationUrl, {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify(client)
				});
				if (!response.ok) throw new ServerError(`Client registration failed: ${response.status}`);
				const data = await response.json();
				return OAuthClientInformationFullSchema.parse(data);
			} }
		};
	}
	async authorize(client, params, c) {
		const targetUrl = new URL(this._endpoints.authorizationUrl);
		const searchParams = new URLSearchParams({
			client_id: client.client_id,
			response_type: "code",
			redirect_uri: params.redirectUri,
			code_challenge: params.codeChallenge,
			code_challenge_method: "S256"
		});
		if (params.state) searchParams.set("state", params.state);
		if (params.scopes?.length) searchParams.set("scope", params.scopes.join(" "));
		if (params.resource) searchParams.set("resource", params.resource.href);
		targetUrl.search = searchParams.toString();
		c.res = c.redirect(targetUrl.toString());
	}
	async challengeForAuthorizationCode(_client, _authorizationCode) {
		return "";
	}
	async exchangeAuthorizationCode(client, authorizationCode, codeVerifier, redirectUri, resource) {
		const params = new URLSearchParams({
			grant_type: "authorization_code",
			client_id: client.client_id,
			code: authorizationCode
		});
		if (client.client_secret) params.append("client_secret", client.client_secret);
		if (codeVerifier) params.append("code_verifier", codeVerifier);
		if (redirectUri) params.append("redirect_uri", redirectUri);
		if (resource) params.append("resource", resource.href);
		const response = await (this._fetch ?? fetch)(this._endpoints.tokenUrl, {
			method: "POST",
			headers: { "Content-Type": "application/x-www-form-urlencoded" },
			body: params.toString()
		});
		if (!response.ok) throw new ServerError(`Token exchange failed: ${response.status}`);
		const data = await response.json();
		return OAuthTokensSchema.parse(data);
	}
	async exchangeRefreshToken(client, refreshToken, scopes, resource) {
		const params = new URLSearchParams({
			grant_type: "refresh_token",
			client_id: client.client_id,
			refresh_token: refreshToken
		});
		if (client.client_secret) params.set("client_secret", client.client_secret);
		if (scopes?.length) params.set("scope", scopes.join(" "));
		if (resource) params.set("resource", resource.href);
		const response = await (this._fetch ?? fetch)(this._endpoints.tokenUrl, {
			method: "POST",
			headers: { "Content-Type": "application/x-www-form-urlencoded" },
			body: params.toString()
		});
		if (!response.ok) throw new ServerError(`Token refresh failed: ${response.status}`);
		const data = await response.json();
		return OAuthTokensSchema.parse(data);
	}
	async verifyAccessToken(token) {
		return this._verifyAccessToken(token);
	}
};

//#endregion
//#region src/auth/simpleAuth.ts
function simpleMcpAuthRouter(options) {
	const { issuer,...wellKnownOptions } = options;
	return wellKnownRouter({
		oauthMetadata: createOAuthMetadata({
			issuerUrl: new URL(issuer),
			scopesSupported: wellKnownOptions.scopesSupported,
			serviceDocumentationUrl: wellKnownOptions.serviceDocumentationUrl
		}),
		...wellKnownOptions
	});
}

//#endregion
export { mcpAuthRouter as a, checkIssuerUrl as c, clientRegistrationHandler as d, authorizeHandler as f, createOAuthMetadata as i, tokenHandler as l, ProxyOAuthServerProvider as n, authenticateClient as o, bearerAuth$1 as r, wellKnownRouter as s, simpleMcpAuthRouter as t, revokeHandler as u };
//# sourceMappingURL=auth-3I0yTyQ0.js.map