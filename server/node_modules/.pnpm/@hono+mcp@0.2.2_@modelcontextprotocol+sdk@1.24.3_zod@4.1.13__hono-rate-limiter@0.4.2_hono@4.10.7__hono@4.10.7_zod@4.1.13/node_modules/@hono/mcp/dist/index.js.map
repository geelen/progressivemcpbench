{"version":3,"file":"index.js","names":["version: string","contextStash: WeakMap<ReadableStream, Context>","#sessionIdGenerator","#enableJsonResponse","#eventStore","#onSessionInitialized","#onSessionClosed","#allowedHosts","#allowedOrigins","#enableDnsRebindingProtection","#started","#validateRequestHeaders","#validateSession","#validateProtocolVersion","streamId: string | ((stream: SSEStreamingApi) => Promise<string>)","#standaloneSseStreamId","#streamMapping","authInfo: AuthInfo | undefined","requestInfo: RequestInfo","messages: JSONRPCMessage[]","#initialized","#requestToStreamMapping","#requestResponseMap","eventId: string | undefined","streamId","#idToIndexMap","#eventIdToStreamIdMap","#eventsPerStreamBufferSize","#idGenerator","#items","#head","#tail","#size","#cleanupCallback","itemsInOrder: T[]"],"sources":["../src/streaming.ts","../src/streamable-http.ts","../src/stores/memory.ts"],"sourcesContent":["import type { Context } from 'hono'\nimport { SSEStreamingApi } from 'hono/streaming'\n\nlet isOldBunVersion = (): boolean => {\n  // @ts-expect-error @types/bun is not installed\n  const version: string = typeof Bun !== 'undefined' ? Bun.version : undefined\n  if (version === undefined) {\n    return false\n  }\n  const result = version.startsWith('1.1') || version.startsWith('1.0') || version.startsWith('0.')\n  // Avoid running this check on every call\n  isOldBunVersion = () => result\n  return result\n}\n\nconst run = async (\n  stream: SSEStreamingApi,\n  cb: (stream: SSEStreamingApi) => Promise<void>,\n  onError?: (e: Error, stream: SSEStreamingApi) => Promise<void>\n): Promise<void> => {\n  try {\n    await cb(stream)\n  } catch (e) {\n    if (e instanceof Error && onError) {\n      await onError(e, stream)\n\n      await stream.writeSSE({\n        event: 'error',\n        data: e.message,\n      })\n    } else {\n      console.error(e)\n    }\n  }\n}\n\nconst contextStash: WeakMap<ReadableStream, Context> = new WeakMap<ReadableStream, Context>()\n\nexport const streamSSE = (\n  c: Context,\n  cb: (stream: SSEStreamingApi) => Promise<void>,\n  onError?: (e: Error, stream: SSEStreamingApi) => Promise<void>\n): Response => {\n  const { readable, writable } = new TransformStream()\n  const stream = new SSEStreamingApi(writable, readable)\n\n  // Until Bun v1.1.27, Bun didn't call cancel() on the ReadableStream for Response objects from Bun.serve()\n  if (isOldBunVersion()) {\n    c.req.raw.signal.addEventListener('abort', () => {\n      if (!stream.closed) {\n        stream.abort()\n      }\n    })\n  }\n\n  // in bun, `c` is destroyed when the request is returned, so hold it until the end of streaming\n  contextStash.set(stream.responseReadable, c)\n\n  c.header('Transfer-Encoding', 'chunked')\n  c.header('Content-Type', 'text/event-stream')\n  c.header('Cache-Control', 'no-cache')\n  c.header('Connection', 'keep-alive')\n\n  run(stream, cb, onError)\n\n  return c.newResponse(stream.responseReadable)\n}\n","/**\n * @module\n * MCP HTTP Streaming Helper for Hono.\n */\nimport type { AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js'\nimport type {\n  EventStore,\n  StreamableHTTPServerTransportOptions,\n} from '@modelcontextprotocol/sdk/server/streamableHttp.js'\nimport type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js'\nimport type {\n  JSONRPCMessage,\n  MessageExtraInfo,\n  RequestId,\n  RequestInfo,\n} from '@modelcontextprotocol/sdk/types.js'\nimport {\n  DEFAULT_NEGOTIATED_PROTOCOL_VERSION,\n  ErrorCode,\n  isInitializeRequest,\n  isJSONRPCError,\n  isJSONRPCRequest,\n  isJSONRPCResponse,\n  JSONRPCMessageSchema,\n  SUPPORTED_PROTOCOL_VERSIONS,\n} from '@modelcontextprotocol/sdk/types.js'\nimport type { Context } from 'hono'\nimport { HTTPException } from 'hono/http-exception'\nimport type { SSEStreamingApi } from 'hono/streaming'\nimport { streamSSE } from './streaming'\n\nexport class StreamableHTTPTransport implements Transport {\n  #started = false\n  #initialized = false\n  #onSessionInitialized?: (sessionId: string) => void | Promise<void>\n  #onSessionClosed?: (sessionId: string) => void | Promise<void>\n  #sessionIdGenerator?: () => string\n  #eventStore?: EventStore\n  #enableJsonResponse = false\n  #standaloneSseStreamId = '_GET_stream'\n  #streamMapping = new Map<\n    string,\n    {\n      ctx: {\n        header: (name: string, value: string) => void\n        json?: (data: unknown) => void\n      }\n      stream?: SSEStreamingApi\n      cleanup: () => void\n    }\n  >()\n  #requestToStreamMapping = new Map<RequestId, string>()\n  #requestResponseMap = new Map<RequestId, JSONRPCMessage>()\n  #allowedHosts?: string[]\n  #allowedOrigins?: string[]\n  #enableDnsRebindingProtection: boolean\n\n  sessionId?: string\n  onclose?: () => void\n  onerror?: (error: Error) => void\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void\n\n  constructor(options?: StreamableHTTPServerTransportOptions) {\n    this.#sessionIdGenerator = options?.sessionIdGenerator\n    this.#enableJsonResponse = options?.enableJsonResponse ?? false\n    this.#eventStore = options?.eventStore\n    this.#onSessionInitialized = options?.onsessioninitialized\n    this.#onSessionClosed = options?.onsessionclosed\n    this.#allowedHosts = options?.allowedHosts\n    this.#allowedOrigins = options?.allowedOrigins\n    this.#enableDnsRebindingProtection = options?.enableDnsRebindingProtection ?? false\n  }\n\n  /**\n   * Starts the transport. This is required by the Transport interface but is a no-op\n   * for the Streamable HTTP transport as connections are managed per-request.\n   */\n  async start(): Promise<void> {\n    if (this.#started) {\n      throw new Error('Transport already started')\n    }\n    this.#started = true\n  }\n\n  /**\n   * Validates request headers for DNS rebinding protection.\n   * @returns Error message if validation fails, undefined if validation passes.\n   */\n  #validateRequestHeaders(ctx: Context): string | undefined {\n    // Skip validation if protection is not enabled\n    if (!this.#enableDnsRebindingProtection) {\n      return undefined\n    }\n\n    // Validate Host header if allowedHosts is configured\n    if (this.#allowedHosts && this.#allowedHosts.length > 0) {\n      const hostHeader = ctx.req.header('Host')\n      if (!hostHeader || !this.#allowedHosts.includes(hostHeader)) {\n        return `Invalid Host header: ${hostHeader}`\n      }\n    }\n\n    // Validate Origin header if allowedOrigins is configured\n    if (this.#allowedOrigins && this.#allowedOrigins.length > 0) {\n      const originHeader = ctx.req.header('Origin')\n      if (!originHeader || !this.#allowedOrigins.includes(originHeader)) {\n        return `Invalid Origin header: ${originHeader}`\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * Handles an incoming HTTP request, whether GET or POST\n   */\n  async handleRequest(ctx: Context, parsedBody?: unknown): Promise<Response | undefined> {\n    // Validate request headers for DNS rebinding protection\n    const validationError = this.#validateRequestHeaders(ctx)\n    if (validationError) {\n      throw new HTTPException(403, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: -32000,\n            message: validationError,\n          },\n          id: null,\n        }),\n      })\n    }\n\n    switch (ctx.req.method) {\n      case 'GET':\n        return this.handleGetRequest(ctx)\n      case 'POST':\n        return this.handlePostRequest(ctx, parsedBody)\n      case 'DELETE':\n        return this.handleDeleteRequest(ctx)\n      default:\n        return this.handleUnsupportedRequest(ctx)\n    }\n  }\n\n  /**\n   * Handles GET requests for SSE stream\n   */\n  private async handleGetRequest(ctx: Context) {\n    try {\n      // The client MUST include an Accept header, listing text/event-stream as a supported content type.\n      const acceptHeader = ctx.req.header('Accept')\n      if (!acceptHeader?.includes('text/event-stream')) {\n        throw new HTTPException(406, {\n          res: Response.json({\n            jsonrpc: '2.0',\n            error: {\n              code: -32000,\n              message: 'Not Acceptable: Client must accept text/event-stream',\n            },\n            id: null,\n          }),\n        })\n      }\n\n      // If an Mcp-Session-Id is returned by the server during initialization,\n      // clients using the Streamable HTTP transport MUST include it\n      // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n      this.#validateSession(ctx)\n      this.#validateProtocolVersion(ctx)\n\n      // After initialization, always include the session ID if we have one\n      if (this.sessionId !== undefined) {\n        ctx.header('mcp-session-id', this.sessionId)\n      }\n\n      let streamId: string | ((stream: SSEStreamingApi) => Promise<string>) =\n        this.#standaloneSseStreamId\n\n      // Handle resumability: check for Last-Event-ID header\n      if (this.#eventStore) {\n        const lastEventId = ctx.req.header('last-event-id')\n        if (lastEventId) {\n          streamId = (stream) =>\n            this.#eventStore!.replayEventsAfter(lastEventId, {\n              send: async (eventId: string, message: JSONRPCMessage) => {\n                try {\n                  await stream.writeSSE({\n                    id: eventId,\n                    event: 'message',\n                    data: JSON.stringify(message),\n                  })\n                } catch {\n                  this.onerror?.(new Error('Failed replay events'))\n                  throw new HTTPException(500, {\n                    message: 'Failed replay events',\n                  })\n                }\n              },\n            })\n        }\n      }\n\n      // Check if there's already an active standalone SSE stream for this session\n      if (typeof streamId === 'string' && this.#streamMapping.get(streamId) !== undefined) {\n        // Only one GET SSE stream is allowed per session\n        throw new HTTPException(409, {\n          res: Response.json({\n            jsonrpc: '2.0',\n            error: {\n              code: -32000,\n              message: 'Conflict: Only one SSE stream is allowed per session',\n            },\n            id: null,\n          }),\n        })\n      }\n\n      return streamSSE(ctx, async (stream) => {\n        const resolvedStreamId = typeof streamId === 'string' ? streamId : await streamId(stream)\n\n        // Keep connection alive\n        const keepAlive = setInterval(() => {\n          if (!stream.closed) {\n            stream.writeSSE({ data: '', event: 'ping' }).catch(() => {\n              stream.abort()\n            })\n          }\n        }, 30000)\n\n        // Unref the timer to avoid blocking the server from shutting down\n        if (typeof keepAlive === 'object' && 'unref' in keepAlive) {\n          ;(keepAlive as any).unref()\n        }\n\n        // Assign the response to the standalone SSE stream\n        this.#streamMapping.set(resolvedStreamId, {\n          ctx: { header: ctx.header },\n          stream,\n          cleanup: () => {\n            clearInterval(keepAlive)\n            this.#streamMapping.delete(resolvedStreamId)\n          },\n        })\n\n        // Set up close handler for client disconnects\n        stream.onAbort(() => {\n          this.#streamMapping.get(resolvedStreamId)?.cleanup()\n        })\n      })\n    } catch (error) {\n      if (error instanceof HTTPException) {\n        throw error\n      }\n\n      this.onerror?.(error as Error)\n\n      // return JSON-RPC formatted error\n      throw new HTTPException(400, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: ErrorCode.ParseError,\n            message: 'Parse error',\n            data: String(error),\n          },\n          id: null,\n        }),\n      })\n    }\n  }\n\n  /**\n   * Handles POST requests containing JSON-RPC messages\n   */\n  private async handlePostRequest(ctx: Context, parsedBody?: unknown) {\n    try {\n      // Validate the Accept header\n      const acceptHeader = ctx.req.header('Accept')\n      // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n      if (\n        !acceptHeader?.includes('application/json') ||\n        !acceptHeader.includes('text/event-stream')\n      ) {\n        throw new HTTPException(406, {\n          res: Response.json({\n            jsonrpc: '2.0',\n            error: {\n              code: ErrorCode.ConnectionClosed,\n              message:\n                'Not Acceptable: Client must accept both application/json and text/event-stream',\n            },\n            id: null,\n          }),\n        })\n      }\n\n      const ct = ctx.req.header('Content-Type')\n      if (!ct?.includes('application/json')) {\n        throw new HTTPException(415, {\n          res: Response.json({\n            jsonrpc: '2.0',\n            error: {\n              code: ErrorCode.ConnectionClosed,\n              message: 'Unsupported Media Type: Content-Type must be application/json',\n            },\n            id: null,\n          }),\n        })\n      }\n\n      const authInfo: AuthInfo | undefined = ctx.get('auth')\n      const requestInfo: RequestInfo = { headers: ctx.req.header() }\n\n      let rawMessage = parsedBody\n      if (rawMessage === undefined) {\n        rawMessage = await ctx.req.json()\n      }\n\n      let messages: JSONRPCMessage[]\n\n      // handle batch and single messages\n      if (Array.isArray(rawMessage)) {\n        messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg))\n      } else {\n        messages = [JSONRPCMessageSchema.parse(rawMessage)]\n      }\n\n      // Check if this is an initialization request\n      // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n      const isInitializationRequest = messages.some(isInitializeRequest)\n      if (isInitializationRequest) {\n        // If it's a server with session management and the session ID is already set we should reject the request\n        // to avoid re-initialization.\n        if (this.#initialized && this.sessionId !== undefined) {\n          throw new HTTPException(400, {\n            res: Response.json({\n              jsonrpc: '2.0',\n              error: {\n                code: ErrorCode.InvalidRequest,\n                message: 'Invalid Request: Server already initialized',\n              },\n              id: null,\n            }),\n          })\n        }\n\n        if (messages.length > 1) {\n          throw new HTTPException(400, {\n            res: Response.json({\n              jsonrpc: '2.0',\n              error: {\n                code: ErrorCode.InvalidRequest,\n                message: 'Invalid Request: Only one initialization request is allowed',\n              },\n              id: null,\n            }),\n          })\n        }\n        this.sessionId = this.#sessionIdGenerator?.()\n        this.#initialized = true\n\n        // If we have a session ID and an onsessioninitialized handler, call it immediately\n        // This is needed in cases where the server needs to keep track of multiple sessions\n        if (this.sessionId && this.#onSessionInitialized) {\n          await this.#onSessionInitialized(this.sessionId)\n        }\n      }\n\n      if (!isInitializationRequest) {\n        // If an Mcp-Session-Id is returned by the server during initialization,\n        // clients using the Streamable HTTP transport MUST include it\n        // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n        this.#validateSession(ctx)\n        // Mcp-Protocol-Version header is required for all requests after initialization.\n        this.#validateProtocolVersion(ctx)\n      }\n\n      // check if it contains requests\n      const hasRequests = messages.some(isJSONRPCRequest)\n\n      if (!hasRequests) {\n        // handle each message\n        for (const message of messages) {\n          this.onmessage?.(message, { authInfo, requestInfo })\n        }\n\n        // if it only contains notifications or responses, return 202\n        return ctx.json(null, { status: 202 })\n      }\n\n      if (hasRequests) {\n        // The default behavior is to use SSE streaming\n        // but in some cases server will return JSON responses\n        const streamId = crypto.randomUUID()\n\n        if (!this.#enableJsonResponse && this.sessionId !== undefined) {\n          ctx.header('mcp-session-id', this.sessionId)\n        }\n\n        if (this.#enableJsonResponse) {\n          // Store the response for this request to send messages back through this connection\n          // We need to track by request ID to maintain the connection\n          const result = await new Promise<Response>((resolve) => {\n            for (const message of messages) {\n              if (isJSONRPCRequest(message)) {\n                this.#streamMapping.set(streamId, {\n                  ctx: {\n                    header: ctx.header,\n                    json: (data) => {\n                      resolve(ctx.json(data as JSONRPCMessage))\n                    },\n                  },\n                  cleanup: () => {\n                    this.#streamMapping.delete(streamId)\n                  },\n                })\n                this.#requestToStreamMapping.set(message.id, streamId)\n              }\n            }\n\n            // handle each message\n            for (const message of messages) {\n              this.onmessage?.(message, { authInfo, requestInfo })\n            }\n          })\n\n          return result\n        }\n\n        return streamSSE(ctx, async (stream) => {\n          // Store the response for this request to send messages back through this connection\n          // We need to track by request ID to maintain the connection\n          for (const message of messages) {\n            if (isJSONRPCRequest(message)) {\n              this.#streamMapping.set(streamId, {\n                ctx: { header: ctx.header },\n                stream,\n                cleanup: () => {\n                  this.#streamMapping.delete(streamId)\n                },\n              })\n              this.#requestToStreamMapping.set(message.id, streamId)\n            }\n          }\n\n          // handle each message\n          for (const message of messages) {\n            this.onmessage?.(message, { authInfo, requestInfo })\n          }\n          // The server SHOULD NOT close the SSE stream before sending all JSON-RPC responses\n          // This will be handled by the send() method when responses are ready\n\n          // Set up close handler for client disconnects\n          stream.onAbort(() => {\n            this.#streamMapping.get(streamId)?.cleanup()\n          })\n        })\n      }\n    } catch (error) {\n      if (error instanceof HTTPException) {\n        throw error\n      }\n\n      this.onerror?.(error as Error)\n\n      // return JSON-RPC formatted error\n      throw new HTTPException(400, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: ErrorCode.ParseError,\n            message: 'Parse error',\n            data: String(error),\n          },\n          id: null,\n        }),\n      })\n    }\n  }\n\n  /**\n   * Handles DELETE requests to terminate sessions\n   */\n  private async handleDeleteRequest(ctx: Context) {\n    this.#validateSession(ctx)\n    this.#validateProtocolVersion(ctx)\n\n    if (this.#onSessionClosed && this.sessionId)\n      await Promise.resolve(this.#onSessionClosed(this.sessionId))\n\n    await this.close()\n    return ctx.body(null, 200)\n  }\n\n  /**\n   * Handles unsupported requests (PUT, PATCH, etc.)\n   */\n  private handleUnsupportedRequest(ctx: Context) {\n    return ctx.json(\n      {\n        jsonrpc: '2.0',\n        error: {\n          code: ErrorCode.ConnectionClosed,\n          message: 'Method not allowed.',\n        },\n        id: null,\n      },\n      {\n        status: 405,\n        headers: {\n          Allow: 'GET, POST, DELETE',\n        },\n      }\n    )\n  }\n\n  /**\n   * Validates session ID for non-initialization requests\n   * Returns true if the session is valid, false otherwise\n   */\n  #validateSession(ctx: Context): boolean {\n    if (this.#sessionIdGenerator === undefined) {\n      // If the sessionIdGenerator ID is not set, the session management is disabled\n      // and we don't need to validate the session ID\n      return true\n    }\n    if (!this.#initialized) {\n      // If the server has not been initialized yet, reject all requests\n      throw new HTTPException(400, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: ErrorCode.ConnectionClosed,\n            message: 'Bad Request: Server not initialized',\n          },\n          id: null,\n        }),\n      })\n    }\n\n    const sessionId = ctx.req.header('mcp-session-id')\n\n    if (!sessionId) {\n      // Non-initialization requests without a session ID should return 400 Bad Request\n      throw new HTTPException(400, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: ErrorCode.ConnectionClosed,\n            message: 'Bad Request: Mcp-Session-Id header is required',\n          },\n          id: null,\n        }),\n      })\n    }\n\n    if (Array.isArray(sessionId)) {\n      throw new HTTPException(400, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: ErrorCode.ConnectionClosed,\n            message: 'Bad Request: Mcp-Session-Id header must be a single value',\n          },\n          id: null,\n        }),\n      })\n    }\n\n    if (sessionId !== this.sessionId) {\n      // Reject requests with invalid session ID with 404 Not Found\n      throw new HTTPException(404, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: ErrorCode.RequestTimeout,\n            message: 'Session not found',\n          },\n          id: null,\n        }),\n      })\n    }\n\n    return true\n  }\n\n  #validateProtocolVersion(ctx: Context): boolean {\n    let protocolVersion =\n      ctx.req.header('mcp-protocol-version') ?? DEFAULT_NEGOTIATED_PROTOCOL_VERSION\n    if (Array.isArray(protocolVersion)) {\n      protocolVersion = protocolVersion[protocolVersion.length - 1]\n    }\n\n    if (!SUPPORTED_PROTOCOL_VERSIONS.includes(protocolVersion)) {\n      throw new HTTPException(404, {\n        res: Response.json({\n          jsonrpc: '2.0',\n          error: {\n            code: ErrorCode.ConnectionClosed,\n            message: `Bad Request: Unsupported protocol version (supported versions: ${SUPPORTED_PROTOCOL_VERSIONS.join(', ')})`,\n          },\n          id: null,\n        }),\n      })\n    }\n    return true\n  }\n\n  async close(): Promise<void> {\n    // Close all SSE connections\n\n    for (const { stream } of this.#streamMapping.values()) {\n      stream?.abort()\n    }\n\n    this.#streamMapping.clear()\n\n    // Clear any pending responses\n    this.#requestResponseMap.clear()\n    this.onclose?.()\n  }\n\n  async send(message: JSONRPCMessage, options?: { relatedRequestId?: RequestId }): Promise<void> {\n    let requestId = options?.relatedRequestId\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      // If the message is a response, use the request ID from the message\n      requestId = message.id\n    }\n\n    // Check if this message should be sent on the standalone SSE stream (no request ID)\n    // Ignore notifications from tools (which have relatedRequestId set)\n    // Those will be sent via dedicated response SSE streams\n    if (requestId === undefined) {\n      // For standalone SSE streams, we can only send requests and notifications\n      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n        throw new Error(\n          'Cannot send a response on a standalone SSE stream unless resuming a previous client request'\n        )\n      }\n      const standaloneSse = this.#streamMapping.get(this.#standaloneSseStreamId)\n\n      if (standaloneSse === undefined) {\n        // The spec says the server MAY send messages on the stream, so it's ok to discard if no stream\n        return\n      }\n\n      // Generate and store event ID if event store is provided\n      let eventId: string | undefined\n      if (this.#eventStore) {\n        // Stores the event and gets the generated event ID\n        eventId = await this.#eventStore.storeEvent(this.#standaloneSseStreamId, message)\n      }\n\n      // Send the message to the standalone SSE stream\n      return standaloneSse.stream?.writeSSE({\n        id: eventId,\n        event: 'message',\n        data: JSON.stringify(message),\n      })\n    }\n\n    // Get the response for this request\n    const streamId = this.#requestToStreamMapping.get(requestId)\n    const response = this.#streamMapping.get(streamId!)\n    if (!streamId) {\n      throw new Error(`No connection established for request ID: ${String(requestId)}`)\n    }\n\n    if (!this.#enableJsonResponse) {\n      // For SSE responses, generate event ID if event store is provided\n      let eventId: string | undefined\n\n      if (this.#eventStore) {\n        eventId = await this.#eventStore.storeEvent(streamId, message)\n      }\n\n      if (response) {\n        // Write the event to the response stream\n        await response.stream?.writeSSE({\n          id: eventId,\n          event: 'message',\n          data: JSON.stringify(message),\n        })\n      }\n    }\n\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      this.#requestResponseMap.set(requestId, message)\n      const relatedIds = Array.from(this.#requestToStreamMapping.entries())\n        .filter(([, streamId]) => this.#streamMapping.get(streamId) === response)\n        .map(([id]) => id)\n\n      // Check if we have responses for all requests using this connection\n      const allResponsesReady = relatedIds.every((id) => this.#requestResponseMap.has(id))\n\n      if (allResponsesReady) {\n        if (!response) {\n          throw new Error(`No connection established for request ID: ${String(requestId)}`)\n        }\n        if (this.#enableJsonResponse) {\n          // All responses ready, send as JSON\n          if (this.sessionId !== undefined) {\n            response.ctx.header('mcp-session-id', this.sessionId)\n          }\n\n          const responses = relatedIds.map((id) => this.#requestResponseMap.get(id)!)\n\n          response.ctx.json?.(responses.length === 1 ? responses[0] : responses)\n          return\n        } else {\n          response.stream?.abort()\n        }\n        // Clean up\n        for (const id of relatedIds) {\n          this.#requestResponseMap.delete(id)\n          this.#requestToStreamMapping.delete(id)\n        }\n      }\n    }\n  }\n}\n","import type { EventStore } from '@modelcontextprotocol/sdk/server/streamableHttp.js'\nimport type { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js'\n\nexport type MemoryEventStoreOptions = {\n  /**\n   * The number of streams to store in the memory\n   * @default 100\n   */\n  streamBufferSize?: number\n  /**\n   * The number of events to store per stream in the memory\n   * @default 100\n   */\n  eventsPerStreamBufferSize?: number\n  /**\n   * The function to generate a unique id for the event\n   * @default () => crypto.randomUUID()\n   */\n  idGenerator?: () => string\n}\n\n/**\n * Simple in-memory implementation of EventStore for resumability\n */\nexport class MemoryEventStore implements EventStore {\n  #eventsPerStreamBufferSize: number\n  #items: RingBuffer<{\n    streamId: string\n    events: RingBuffer<{ id: string; message: JSONRPCMessage }>\n  }>\n  #idToIndexMap: Map<string, number>\n  #eventIdToStreamIdMap: Map<string, string>\n  #idGenerator: () => string\n\n  constructor(options: MemoryEventStoreOptions = {}) {\n    const {\n      streamBufferSize = 100,\n      eventsPerStreamBufferSize = 100,\n      idGenerator = () => crypto.randomUUID(),\n    } = options\n\n    this.#idToIndexMap = new Map()\n    this.#eventIdToStreamIdMap = new Map()\n\n    this.#eventsPerStreamBufferSize = eventsPerStreamBufferSize\n    this.#idGenerator = idGenerator\n\n    this.#items = new RingBuffer(streamBufferSize, ({ streamId, events }) => {\n      this.#idToIndexMap.delete(streamId)\n      events.reset()\n    })\n  }\n\n  async storeEvent(streamId: string, message: JSONRPCMessage): Promise<string> {\n    const eventId = this.#idGenerator()\n    this.#eventIdToStreamIdMap.set(eventId, streamId)\n\n    if (\n      !this.#idToIndexMap.has(streamId) ||\n      this.#items.get(this.#idToIndexMap.get(streamId)!) == null\n    ) {\n      this.#idToIndexMap.set(streamId, this.#items.head)\n      this.#items.push({\n        streamId,\n        events: new RingBuffer(this.#eventsPerStreamBufferSize, ({ id }) => {\n          this.#eventIdToStreamIdMap.delete(id)\n        }),\n      })\n    }\n\n    // Adding the message in the stream\n    this.#items.get(this.#idToIndexMap.get(streamId)!)!.events.push({ id: eventId, message })\n\n    return eventId\n  }\n\n  async replayEventsAfter(\n    lastEventId: string,\n    sender: { send: (eventId: string, message: JSONRPCMessage) => Promise<void> }\n  ): Promise<string> {\n    const streamId = this.#eventIdToStreamIdMap.get(lastEventId)\n    if (!streamId) {\n      return '_unknown_stream'\n    }\n\n    const streamEvents = this.#items.get(this.#idToIndexMap.get(streamId)!)!.events.read()\n    const lastEventIndex = streamEvents.findIndex((event) => event.id === lastEventId)\n\n    // If the last event is found, replay events after it, otherwise replay all events\n    const filteredStreamEvents =\n      lastEventIndex > -1 ? streamEvents.slice(lastEventIndex + 1) : streamEvents\n\n    for (const event of filteredStreamEvents) {\n      await sender.send(event.id, event.message)\n    }\n\n    return streamId\n  }\n\n  reset(): void {\n    this.#items.reset()\n    this.#idToIndexMap.clear()\n    this.#eventIdToStreamIdMap.clear()\n  }\n}\n\n/**\n * Simple ring buffer implementation\n * @internal\n */\nexport class RingBuffer<T> {\n  #items: T[]\n  #head: number\n  #tail: number\n  #size: number\n  #cleanupCallback?: (item: T) => void\n\n  constructor(size: number, cleanupCallback?: (item: T) => void) {\n    this.#items = new Array(size)\n    this.#head = 0\n    this.#tail = 0\n    this.#size = size\n    this.#cleanupCallback = cleanupCallback\n  }\n\n  get head(): number {\n    return this.#head\n  }\n\n  push(item: T): void {\n    const index = this.#head % this.#size\n\n    const oldValue = this.#items[index]\n    if (oldValue != null && this.#cleanupCallback != null) {\n      this.#cleanupCallback(oldValue)\n    }\n\n    this.#items[index] = item\n    this.#head++\n    this.#tail = Math.max(this.#tail, this.#head - this.#size)\n  }\n\n  get(index: number): T | undefined {\n    if (index < this.#tail || index >= this.#head) {\n      return undefined\n    }\n\n    return this.#items[index % this.#size]\n  }\n\n  read(): T[] {\n    const itemsInOrder: T[] = []\n    for (let i = this.#tail; i < this.#head; i++) {\n      const item = this.get(i)\n\n      if (item == null) break\n\n      itemsInOrder.push(item)\n    }\n\n    return itemsInOrder\n  }\n\n  reset(): void {\n    if (this.#cleanupCallback != null) {\n      for (const item of this.read()) {\n        this.#cleanupCallback(item)\n      }\n    }\n\n    this.#items = new Array(this.#size)\n    this.#head = 0\n    this.#tail = 0\n  }\n}\n"],"mappings":"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"}