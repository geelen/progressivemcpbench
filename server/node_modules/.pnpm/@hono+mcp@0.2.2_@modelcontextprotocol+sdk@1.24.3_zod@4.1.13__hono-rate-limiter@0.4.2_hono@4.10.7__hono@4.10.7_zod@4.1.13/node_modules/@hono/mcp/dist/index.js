import { a as mcpAuthRouter, n as ProxyOAuthServerProvider, r as bearerAuth, t as simpleMcpAuthRouter } from "./auth-3I0yTyQ0.js";
import { DEFAULT_NEGOTIATED_PROTOCOL_VERSION, ErrorCode, JSONRPCMessageSchema, SUPPORTED_PROTOCOL_VERSIONS, isInitializeRequest, isJSONRPCError, isJSONRPCRequest, isJSONRPCResponse } from "@modelcontextprotocol/sdk/types.js";
import { HTTPException } from "hono/http-exception";
import { SSEStreamingApi } from "hono/streaming";

//#region src/streaming.ts
let isOldBunVersion = () => {
	const version = typeof Bun !== "undefined" ? Bun.version : void 0;
	if (version === void 0) return false;
	const result = version.startsWith("1.1") || version.startsWith("1.0") || version.startsWith("0.");
	isOldBunVersion = () => result;
	return result;
};
const run = async (stream, cb, onError) => {
	try {
		await cb(stream);
	} catch (e) {
		if (e instanceof Error && onError) {
			await onError(e, stream);
			await stream.writeSSE({
				event: "error",
				data: e.message
			});
		} else console.error(e);
	}
};
const contextStash = /* @__PURE__ */ new WeakMap();
const streamSSE = (c, cb, onError) => {
	const { readable, writable } = new TransformStream();
	const stream = new SSEStreamingApi(writable, readable);
	if (isOldBunVersion()) c.req.raw.signal.addEventListener("abort", () => {
		if (!stream.closed) stream.abort();
	});
	contextStash.set(stream.responseReadable, c);
	c.header("Transfer-Encoding", "chunked");
	c.header("Content-Type", "text/event-stream");
	c.header("Cache-Control", "no-cache");
	c.header("Connection", "keep-alive");
	run(stream, cb, onError);
	return c.newResponse(stream.responseReadable);
};

//#endregion
//#region src/streamable-http.ts
var StreamableHTTPTransport = class {
	#started = false;
	#initialized = false;
	#onSessionInitialized;
	#onSessionClosed;
	#sessionIdGenerator;
	#eventStore;
	#enableJsonResponse = false;
	#standaloneSseStreamId = "_GET_stream";
	#streamMapping = /* @__PURE__ */ new Map();
	#requestToStreamMapping = /* @__PURE__ */ new Map();
	#requestResponseMap = /* @__PURE__ */ new Map();
	#allowedHosts;
	#allowedOrigins;
	#enableDnsRebindingProtection;
	sessionId;
	onclose;
	onerror;
	onmessage;
	constructor(options) {
		this.#sessionIdGenerator = options?.sessionIdGenerator;
		this.#enableJsonResponse = options?.enableJsonResponse ?? false;
		this.#eventStore = options?.eventStore;
		this.#onSessionInitialized = options?.onsessioninitialized;
		this.#onSessionClosed = options?.onsessionclosed;
		this.#allowedHosts = options?.allowedHosts;
		this.#allowedOrigins = options?.allowedOrigins;
		this.#enableDnsRebindingProtection = options?.enableDnsRebindingProtection ?? false;
	}
	/**
	* Starts the transport. This is required by the Transport interface but is a no-op
	* for the Streamable HTTP transport as connections are managed per-request.
	*/
	async start() {
		if (this.#started) throw new Error("Transport already started");
		this.#started = true;
	}
	/**
	* Validates request headers for DNS rebinding protection.
	* @returns Error message if validation fails, undefined if validation passes.
	*/
	#validateRequestHeaders(ctx) {
		if (!this.#enableDnsRebindingProtection) return;
		if (this.#allowedHosts && this.#allowedHosts.length > 0) {
			const hostHeader = ctx.req.header("Host");
			if (!hostHeader || !this.#allowedHosts.includes(hostHeader)) return `Invalid Host header: ${hostHeader}`;
		}
		if (this.#allowedOrigins && this.#allowedOrigins.length > 0) {
			const originHeader = ctx.req.header("Origin");
			if (!originHeader || !this.#allowedOrigins.includes(originHeader)) return `Invalid Origin header: ${originHeader}`;
		}
	}
	/**
	* Handles an incoming HTTP request, whether GET or POST
	*/
	async handleRequest(ctx, parsedBody) {
		const validationError = this.#validateRequestHeaders(ctx);
		if (validationError) throw new HTTPException(403, { res: Response.json({
			jsonrpc: "2.0",
			error: {
				code: -32e3,
				message: validationError
			},
			id: null
		}) });
		switch (ctx.req.method) {
			case "GET": return this.handleGetRequest(ctx);
			case "POST": return this.handlePostRequest(ctx, parsedBody);
			case "DELETE": return this.handleDeleteRequest(ctx);
			default: return this.handleUnsupportedRequest(ctx);
		}
	}
	/**
	* Handles GET requests for SSE stream
	*/
	async handleGetRequest(ctx) {
		try {
			if (!ctx.req.header("Accept")?.includes("text/event-stream")) throw new HTTPException(406, { res: Response.json({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Not Acceptable: Client must accept text/event-stream"
				},
				id: null
			}) });
			this.#validateSession(ctx);
			this.#validateProtocolVersion(ctx);
			if (this.sessionId !== void 0) ctx.header("mcp-session-id", this.sessionId);
			let streamId = this.#standaloneSseStreamId;
			if (this.#eventStore) {
				const lastEventId = ctx.req.header("last-event-id");
				if (lastEventId) streamId = (stream) => this.#eventStore.replayEventsAfter(lastEventId, { send: async (eventId, message) => {
					try {
						await stream.writeSSE({
							id: eventId,
							event: "message",
							data: JSON.stringify(message)
						});
					} catch {
						this.onerror?.(/* @__PURE__ */ new Error("Failed replay events"));
						throw new HTTPException(500, { message: "Failed replay events" });
					}
				} });
			}
			if (typeof streamId === "string" && this.#streamMapping.get(streamId) !== void 0) throw new HTTPException(409, { res: Response.json({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Conflict: Only one SSE stream is allowed per session"
				},
				id: null
			}) });
			return streamSSE(ctx, async (stream) => {
				const resolvedStreamId = typeof streamId === "string" ? streamId : await streamId(stream);
				const keepAlive = setInterval(() => {
					if (!stream.closed) stream.writeSSE({
						data: "",
						event: "ping"
					}).catch(() => {
						stream.abort();
					});
				}, 3e4);
				if (typeof keepAlive === "object" && "unref" in keepAlive) keepAlive.unref();
				this.#streamMapping.set(resolvedStreamId, {
					ctx: { header: ctx.header },
					stream,
					cleanup: () => {
						clearInterval(keepAlive);
						this.#streamMapping.delete(resolvedStreamId);
					}
				});
				stream.onAbort(() => {
					this.#streamMapping.get(resolvedStreamId)?.cleanup();
				});
			});
		} catch (error) {
			if (error instanceof HTTPException) throw error;
			this.onerror?.(error);
			throw new HTTPException(400, { res: Response.json({
				jsonrpc: "2.0",
				error: {
					code: ErrorCode.ParseError,
					message: "Parse error",
					data: String(error)
				},
				id: null
			}) });
		}
	}
	/**
	* Handles POST requests containing JSON-RPC messages
	*/
	async handlePostRequest(ctx, parsedBody) {
		try {
			const acceptHeader = ctx.req.header("Accept");
			if (!acceptHeader?.includes("application/json") || !acceptHeader.includes("text/event-stream")) throw new HTTPException(406, { res: Response.json({
				jsonrpc: "2.0",
				error: {
					code: ErrorCode.ConnectionClosed,
					message: "Not Acceptable: Client must accept both application/json and text/event-stream"
				},
				id: null
			}) });
			if (!ctx.req.header("Content-Type")?.includes("application/json")) throw new HTTPException(415, { res: Response.json({
				jsonrpc: "2.0",
				error: {
					code: ErrorCode.ConnectionClosed,
					message: "Unsupported Media Type: Content-Type must be application/json"
				},
				id: null
			}) });
			const authInfo = ctx.get("auth");
			const requestInfo = { headers: ctx.req.header() };
			let rawMessage = parsedBody;
			if (rawMessage === void 0) rawMessage = await ctx.req.json();
			let messages;
			if (Array.isArray(rawMessage)) messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
			else messages = [JSONRPCMessageSchema.parse(rawMessage)];
			const isInitializationRequest = messages.some(isInitializeRequest);
			if (isInitializationRequest) {
				if (this.#initialized && this.sessionId !== void 0) throw new HTTPException(400, { res: Response.json({
					jsonrpc: "2.0",
					error: {
						code: ErrorCode.InvalidRequest,
						message: "Invalid Request: Server already initialized"
					},
					id: null
				}) });
				if (messages.length > 1) throw new HTTPException(400, { res: Response.json({
					jsonrpc: "2.0",
					error: {
						code: ErrorCode.InvalidRequest,
						message: "Invalid Request: Only one initialization request is allowed"
					},
					id: null
				}) });
				this.sessionId = this.#sessionIdGenerator?.();
				this.#initialized = true;
				if (this.sessionId && this.#onSessionInitialized) await this.#onSessionInitialized(this.sessionId);
			}
			if (!isInitializationRequest) {
				this.#validateSession(ctx);
				this.#validateProtocolVersion(ctx);
			}
			const hasRequests = messages.some(isJSONRPCRequest);
			if (!hasRequests) {
				for (const message of messages) this.onmessage?.(message, {
					authInfo,
					requestInfo
				});
				return ctx.json(null, { status: 202 });
			}
			if (hasRequests) {
				const streamId = crypto.randomUUID();
				if (!this.#enableJsonResponse && this.sessionId !== void 0) ctx.header("mcp-session-id", this.sessionId);
				if (this.#enableJsonResponse) return await new Promise((resolve) => {
					for (const message of messages) if (isJSONRPCRequest(message)) {
						this.#streamMapping.set(streamId, {
							ctx: {
								header: ctx.header,
								json: (data) => {
									resolve(ctx.json(data));
								}
							},
							cleanup: () => {
								this.#streamMapping.delete(streamId);
							}
						});
						this.#requestToStreamMapping.set(message.id, streamId);
					}
					for (const message of messages) this.onmessage?.(message, {
						authInfo,
						requestInfo
					});
				});
				return streamSSE(ctx, async (stream) => {
					for (const message of messages) if (isJSONRPCRequest(message)) {
						this.#streamMapping.set(streamId, {
							ctx: { header: ctx.header },
							stream,
							cleanup: () => {
								this.#streamMapping.delete(streamId);
							}
						});
						this.#requestToStreamMapping.set(message.id, streamId);
					}
					for (const message of messages) this.onmessage?.(message, {
						authInfo,
						requestInfo
					});
					stream.onAbort(() => {
						this.#streamMapping.get(streamId)?.cleanup();
					});
				});
			}
		} catch (error) {
			if (error instanceof HTTPException) throw error;
			this.onerror?.(error);
			throw new HTTPException(400, { res: Response.json({
				jsonrpc: "2.0",
				error: {
					code: ErrorCode.ParseError,
					message: "Parse error",
					data: String(error)
				},
				id: null
			}) });
		}
	}
	/**
	* Handles DELETE requests to terminate sessions
	*/
	async handleDeleteRequest(ctx) {
		this.#validateSession(ctx);
		this.#validateProtocolVersion(ctx);
		if (this.#onSessionClosed && this.sessionId) await Promise.resolve(this.#onSessionClosed(this.sessionId));
		await this.close();
		return ctx.body(null, 200);
	}
	/**
	* Handles unsupported requests (PUT, PATCH, etc.)
	*/
	handleUnsupportedRequest(ctx) {
		return ctx.json({
			jsonrpc: "2.0",
			error: {
				code: ErrorCode.ConnectionClosed,
				message: "Method not allowed."
			},
			id: null
		}, {
			status: 405,
			headers: { Allow: "GET, POST, DELETE" }
		});
	}
	/**
	* Validates session ID for non-initialization requests
	* Returns true if the session is valid, false otherwise
	*/
	#validateSession(ctx) {
		if (this.#sessionIdGenerator === void 0) return true;
		if (!this.#initialized) throw new HTTPException(400, { res: Response.json({
			jsonrpc: "2.0",
			error: {
				code: ErrorCode.ConnectionClosed,
				message: "Bad Request: Server not initialized"
			},
			id: null
		}) });
		const sessionId = ctx.req.header("mcp-session-id");
		if (!sessionId) throw new HTTPException(400, { res: Response.json({
			jsonrpc: "2.0",
			error: {
				code: ErrorCode.ConnectionClosed,
				message: "Bad Request: Mcp-Session-Id header is required"
			},
			id: null
		}) });
		if (Array.isArray(sessionId)) throw new HTTPException(400, { res: Response.json({
			jsonrpc: "2.0",
			error: {
				code: ErrorCode.ConnectionClosed,
				message: "Bad Request: Mcp-Session-Id header must be a single value"
			},
			id: null
		}) });
		if (sessionId !== this.sessionId) throw new HTTPException(404, { res: Response.json({
			jsonrpc: "2.0",
			error: {
				code: ErrorCode.RequestTimeout,
				message: "Session not found"
			},
			id: null
		}) });
		return true;
	}
	#validateProtocolVersion(ctx) {
		let protocolVersion = ctx.req.header("mcp-protocol-version") ?? DEFAULT_NEGOTIATED_PROTOCOL_VERSION;
		if (Array.isArray(protocolVersion)) protocolVersion = protocolVersion[protocolVersion.length - 1];
		if (!SUPPORTED_PROTOCOL_VERSIONS.includes(protocolVersion)) throw new HTTPException(404, { res: Response.json({
			jsonrpc: "2.0",
			error: {
				code: ErrorCode.ConnectionClosed,
				message: `Bad Request: Unsupported protocol version (supported versions: ${SUPPORTED_PROTOCOL_VERSIONS.join(", ")})`
			},
			id: null
		}) });
		return true;
	}
	async close() {
		for (const { stream } of this.#streamMapping.values()) stream?.abort();
		this.#streamMapping.clear();
		this.#requestResponseMap.clear();
		this.onclose?.();
	}
	async send(message, options) {
		let requestId = options?.relatedRequestId;
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) requestId = message.id;
		if (requestId === void 0) {
			if (isJSONRPCResponse(message) || isJSONRPCError(message)) throw new Error("Cannot send a response on a standalone SSE stream unless resuming a previous client request");
			const standaloneSse = this.#streamMapping.get(this.#standaloneSseStreamId);
			if (standaloneSse === void 0) return;
			let eventId;
			if (this.#eventStore) eventId = await this.#eventStore.storeEvent(this.#standaloneSseStreamId, message);
			return standaloneSse.stream?.writeSSE({
				id: eventId,
				event: "message",
				data: JSON.stringify(message)
			});
		}
		const streamId = this.#requestToStreamMapping.get(requestId);
		const response = this.#streamMapping.get(streamId);
		if (!streamId) throw new Error(`No connection established for request ID: ${String(requestId)}`);
		if (!this.#enableJsonResponse) {
			let eventId;
			if (this.#eventStore) eventId = await this.#eventStore.storeEvent(streamId, message);
			if (response) await response.stream?.writeSSE({
				id: eventId,
				event: "message",
				data: JSON.stringify(message)
			});
		}
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
			this.#requestResponseMap.set(requestId, message);
			const relatedIds = Array.from(this.#requestToStreamMapping.entries()).filter(([, streamId$1]) => this.#streamMapping.get(streamId$1) === response).map(([id]) => id);
			if (relatedIds.every((id) => this.#requestResponseMap.has(id))) {
				if (!response) throw new Error(`No connection established for request ID: ${String(requestId)}`);
				if (this.#enableJsonResponse) {
					if (this.sessionId !== void 0) response.ctx.header("mcp-session-id", this.sessionId);
					const responses = relatedIds.map((id) => this.#requestResponseMap.get(id));
					response.ctx.json?.(responses.length === 1 ? responses[0] : responses);
					return;
				} else response.stream?.abort();
				for (const id of relatedIds) {
					this.#requestResponseMap.delete(id);
					this.#requestToStreamMapping.delete(id);
				}
			}
		}
	}
};

//#endregion
//#region src/stores/memory.ts
/**
* Simple in-memory implementation of EventStore for resumability
*/
var MemoryEventStore = class {
	#eventsPerStreamBufferSize;
	#items;
	#idToIndexMap;
	#eventIdToStreamIdMap;
	#idGenerator;
	constructor(options = {}) {
		const { streamBufferSize = 100, eventsPerStreamBufferSize = 100, idGenerator = () => crypto.randomUUID() } = options;
		this.#idToIndexMap = /* @__PURE__ */ new Map();
		this.#eventIdToStreamIdMap = /* @__PURE__ */ new Map();
		this.#eventsPerStreamBufferSize = eventsPerStreamBufferSize;
		this.#idGenerator = idGenerator;
		this.#items = new RingBuffer(streamBufferSize, ({ streamId, events }) => {
			this.#idToIndexMap.delete(streamId);
			events.reset();
		});
	}
	async storeEvent(streamId, message) {
		const eventId = this.#idGenerator();
		this.#eventIdToStreamIdMap.set(eventId, streamId);
		if (!this.#idToIndexMap.has(streamId) || this.#items.get(this.#idToIndexMap.get(streamId)) == null) {
			this.#idToIndexMap.set(streamId, this.#items.head);
			this.#items.push({
				streamId,
				events: new RingBuffer(this.#eventsPerStreamBufferSize, ({ id }) => {
					this.#eventIdToStreamIdMap.delete(id);
				})
			});
		}
		this.#items.get(this.#idToIndexMap.get(streamId)).events.push({
			id: eventId,
			message
		});
		return eventId;
	}
	async replayEventsAfter(lastEventId, sender) {
		const streamId = this.#eventIdToStreamIdMap.get(lastEventId);
		if (!streamId) return "_unknown_stream";
		const streamEvents = this.#items.get(this.#idToIndexMap.get(streamId)).events.read();
		const lastEventIndex = streamEvents.findIndex((event) => event.id === lastEventId);
		const filteredStreamEvents = lastEventIndex > -1 ? streamEvents.slice(lastEventIndex + 1) : streamEvents;
		for (const event of filteredStreamEvents) await sender.send(event.id, event.message);
		return streamId;
	}
	reset() {
		this.#items.reset();
		this.#idToIndexMap.clear();
		this.#eventIdToStreamIdMap.clear();
	}
};
/**
* Simple ring buffer implementation
* @internal
*/
var RingBuffer = class {
	#items;
	#head;
	#tail;
	#size;
	#cleanupCallback;
	constructor(size, cleanupCallback) {
		this.#items = new Array(size);
		this.#head = 0;
		this.#tail = 0;
		this.#size = size;
		this.#cleanupCallback = cleanupCallback;
	}
	get head() {
		return this.#head;
	}
	push(item) {
		const index = this.#head % this.#size;
		const oldValue = this.#items[index];
		if (oldValue != null && this.#cleanupCallback != null) this.#cleanupCallback(oldValue);
		this.#items[index] = item;
		this.#head++;
		this.#tail = Math.max(this.#tail, this.#head - this.#size);
	}
	get(index) {
		if (index < this.#tail || index >= this.#head) return;
		return this.#items[index % this.#size];
	}
	read() {
		const itemsInOrder = [];
		for (let i = this.#tail; i < this.#head; i++) {
			const item = this.get(i);
			if (item == null) break;
			itemsInOrder.push(item);
		}
		return itemsInOrder;
	}
	reset() {
		if (this.#cleanupCallback != null) for (const item of this.read()) this.#cleanupCallback(item);
		this.#items = new Array(this.#size);
		this.#head = 0;
		this.#tail = 0;
	}
};

//#endregion
export { MemoryEventStore, ProxyOAuthServerProvider, StreamableHTTPTransport, bearerAuth, mcpAuthRouter, simpleMcpAuthRouter, streamSSE };
//# sourceMappingURL=index.js.map