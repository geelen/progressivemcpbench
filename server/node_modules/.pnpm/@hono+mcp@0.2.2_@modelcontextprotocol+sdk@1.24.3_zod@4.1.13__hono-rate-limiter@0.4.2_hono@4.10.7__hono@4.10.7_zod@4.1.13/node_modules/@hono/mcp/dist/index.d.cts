import { b as mcpAuthRouter, i as ProxyOAuthServerProvider, n as simpleMcpAuthRouter, o as bearerAuth } from "./index-CyaxwnEU.cjs";
import { Context } from "hono";
import { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import { EventStore, StreamableHTTPServerTransportOptions } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { JSONRPCMessage, MessageExtraInfo, RequestId } from "@modelcontextprotocol/sdk/types.js";
import { SSEStreamingApi } from "hono/streaming";

//#region src/streamable-http.d.ts
declare class StreamableHTTPTransport implements Transport {
  #private;
  sessionId?: string;
  onclose?: () => void;
  onerror?: (error: Error) => void;
  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;
  constructor(options?: StreamableHTTPServerTransportOptions);
  /**
  * Starts the transport. This is required by the Transport interface but is a no-op
  * for the Streamable HTTP transport as connections are managed per-request.
  */
  start(): Promise<void>;
  /**
  * Handles an incoming HTTP request, whether GET or POST
  */
  handleRequest(ctx: Context, parsedBody?: unknown): Promise<Response | undefined>;
  /**
  * Handles GET requests for SSE stream
  */
  private handleGetRequest;
  /**
  * Handles POST requests containing JSON-RPC messages
  */
  private handlePostRequest;
  /**
  * Handles DELETE requests to terminate sessions
  */
  private handleDeleteRequest;
  /**
  * Handles unsupported requests (PUT, PATCH, etc.)
  */
  private handleUnsupportedRequest;
  close(): Promise<void>;
  send(message: JSONRPCMessage, options?: {
    relatedRequestId?: RequestId;
  }): Promise<void>;
}
//#endregion
//#region src/streaming.d.ts
declare const streamSSE: (c: Context, cb: (stream: SSEStreamingApi) => Promise<void>, onError?: (e: Error, stream: SSEStreamingApi) => Promise<void>) => Response;
//#endregion
//#region src/stores/memory.d.ts
type MemoryEventStoreOptions = {
  /**
  * The number of streams to store in the memory
  * @default 100
  */
  streamBufferSize?: number;
  /**
  * The number of events to store per stream in the memory
  * @default 100
  */
  eventsPerStreamBufferSize?: number;
  /**
  * The function to generate a unique id for the event
  * @default () => crypto.randomUUID()
  */
  idGenerator?: () => string;
};
/**
* Simple in-memory implementation of EventStore for resumability
*/
declare class MemoryEventStore implements EventStore {
  #private;
  constructor(options?: MemoryEventStoreOptions);
  storeEvent(streamId: string, message: JSONRPCMessage): Promise<string>;
  replayEventsAfter(lastEventId: string, sender: {
    send: (eventId: string, message: JSONRPCMessage) => Promise<void>;
  }): Promise<string>;
  reset(): void;
}
//#endregion
export { MemoryEventStore, MemoryEventStoreOptions, ProxyOAuthServerProvider, StreamableHTTPTransport, bearerAuth, mcpAuthRouter, simpleMcpAuthRouter, streamSSE };
//# sourceMappingURL=index.d.cts.map