{"version":3,"file":"auth-3I0yTyQ0.js","names":["requestedScopes: string[]","scope","clientInfo: Omit<OAuthClientInformationFull, 'client_id'> & { client_id?: string }","body: any","parseResult","protectedResourceMetadata: OAuthProtectedResourceMetadata","body: any","bearerAuth","bearerAuthMiddleware"],"sources":["../src/auth/helpers/authorize.ts","../src/auth/helpers/register.ts","../src/auth/helpers/revoke.ts","../src/auth/helpers/token.ts","../src/auth/helpers/utils.ts","../src/auth/helpers/wellknown.ts","../src/auth/middleware/client-auth.ts","../src/auth/router.ts","../src/auth/middleware/bearerAuth.ts","../src/auth/providers/proxy-provider.ts","../src/auth/simpleAuth.ts"],"sourcesContent":["import {\n  InvalidClientError,\n  InvalidRequestError,\n  InvalidScopeError,\n  OAuthError,\n  ServerError,\n} from '@modelcontextprotocol/sdk/server/auth/errors.js'\nimport type { OAuthServerProvider } from '@modelcontextprotocol/sdk/server/auth/provider.js'\nimport type { MiddlewareHandler } from 'hono'\nimport * as z from 'zod/v4'\n\n// Parameters that must be validated in order to issue redirects.\nconst ClientAuthorizationParamsSchema = z.object({\n  client_id: z.string(),\n  redirect_uri: z\n    .string()\n    .optional()\n    .refine((value) => value === undefined || URL.canParse(value), {\n      message: 'redirect_uri must be a valid URL',\n    }),\n})\n\n// Parameters that must be validated for a successful authorization request. Failure can be reported to the redirect URI.\nconst RequestAuthorizationParamsSchema = z.object({\n  response_type: z.literal('code'),\n  code_challenge: z.string(),\n  code_challenge_method: z.literal('S256'),\n  scope: z.string().optional(),\n  state: z.string().optional(),\n  resource: z.url().optional(),\n})\n\nexport function authorizeHandler(provider: OAuthServerProvider): MiddlewareHandler {\n  return async (c) => {\n    c.header('Cache-Control', 'no-store')\n\n    // In the authorization flow, errors are split into two categories:\n    // 1. Pre-redirect errors (direct response with 400)\n    // 2. Post-redirect errors (redirect with error parameters)\n\n    // Phase 1: Validate client_id and redirect_uri. Any errors here must be direct responses.\n    let redirect_uri, client\n    try {\n      const result = ClientAuthorizationParamsSchema.safeParse(\n        c.req.method === 'POST' ? await c.req.json() : c.req.query()\n      )\n\n      if (!result.success) {\n        throw new InvalidRequestError(result.error.message)\n      }\n\n      redirect_uri = result.data.redirect_uri\n\n      client = await provider.clientsStore.getClient(result.data.client_id)\n\n      if (!client) {\n        throw new InvalidClientError('Invalid client_id')\n      }\n\n      if (redirect_uri !== undefined) {\n        if (!client.redirect_uris.includes(redirect_uri)) {\n          throw new InvalidRequestError('Unregistered redirect_uri')\n        }\n      } else if (client.redirect_uris.length === 1) {\n        redirect_uri = client.redirect_uris[0]\n      } else {\n        throw new InvalidRequestError(\n          'redirect_uri must be specified when client has multiple registered URIs'\n        )\n      }\n    } catch (error) {\n      // Pre-redirect errors - return direct response\n      //\n      // These don't need to be JSON encoded, as they'll be displayed in a user\n      // agent, but OTOH they all represent exceptional situations (arguably,\n      // \"programmer error\"), so presenting a nice HTML page doesn't help the\n      // user anyway.\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400\n        return c.json(error.toResponseObject(), status)\n      }\n\n      const serverError = new ServerError('Internal Server Error')\n      return c.json(serverError.toResponseObject(), 500)\n    }\n\n    // Phase 2: Validate other parameters. Any errors here should go into redirect responses.\n    let state\n    try {\n      // Parse and validate authorization parameters\n      const parseResult = RequestAuthorizationParamsSchema.safeParse(\n        c.req.method === 'POST' ? await c.req.json() : c.req.query()\n      )\n\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message)\n      }\n\n      const { scope, code_challenge, resource } = parseResult.data\n      state = parseResult.data.state\n\n      // Validate scopes\n      let requestedScopes: string[] = []\n      if (scope !== undefined) {\n        requestedScopes = scope.split(' ')\n        const allowedScopes = new Set(client.scope?.split(' '))\n\n        // Check each requested scope against allowed scopes\n        for (const scope of requestedScopes) {\n          if (!allowedScopes.has(scope)) {\n            throw new InvalidScopeError(`Client was not registered with scope ${scope}`)\n          }\n        }\n      }\n\n      // All validation passed, proceed with authorization\n      await provider.authorize(\n        client,\n        {\n          state,\n          scopes: requestedScopes,\n          redirectUri: redirect_uri,\n          codeChallenge: code_challenge,\n          resource: resource ? new URL(resource) : undefined,\n        },\n        c\n      )\n\n      return c.res\n    } catch (error) {\n      // Post-redirect errors - redirect with error parameters\n      if (error instanceof OAuthError) {\n        return c.redirect(createErrorRedirect(redirect_uri, error, state))\n      }\n\n      const serverError = new ServerError('Internal Server Error')\n      return c.redirect(createErrorRedirect(redirect_uri, serverError, state), 302)\n    }\n  }\n}\n\n/**\n * Helper function to create redirect URL with error parameters\n */\nfunction createErrorRedirect(redirectUri: string, error: OAuthError, state?: string): string {\n  const errorUrl = new URL(redirectUri)\n  errorUrl.searchParams.set('error', error.errorCode)\n  errorUrl.searchParams.set('error_description', error.message)\n  if (error.errorUri) {\n    errorUrl.searchParams.set('error_uri', error.errorUri)\n  }\n  if (state) {\n    errorUrl.searchParams.set('state', state)\n  }\n  return errorUrl.href\n}\n","import type { OAuthRegisteredClientsStore } from '@modelcontextprotocol/sdk/server/auth/clients.js'\nimport {\n  InvalidClientMetadataError,\n  OAuthError,\n  ServerError,\n} from '@modelcontextprotocol/sdk/server/auth/errors.js'\nimport type { OAuthClientInformationFull } from '@modelcontextprotocol/sdk/shared/auth.js'\nimport { OAuthClientMetadataSchema } from '@modelcontextprotocol/sdk/shared/auth.js'\nimport type { MiddlewareHandler } from 'hono'\n\nexport type ClientRegistrationHandlerOptions = {\n  /**\n   * A store used to save information about dynamically registered OAuth clients.\n   */\n  clientsStore: OAuthRegisteredClientsStore\n\n  /**\n   * The number of seconds after which to expire issued client secrets, or 0 to prevent expiration of client secrets (not recommended).\n   *\n   * If not set, defaults to 30 days.\n   */\n  clientSecretExpirySeconds?: number\n\n  /**\n   * Whether to generate a client ID before calling the client registration endpoint.\n   *\n   * If not set, defaults to true.\n   */\n  clientIdGeneration?: boolean\n}\n\nconst DEFAULT_CLIENT_SECRET_EXPIRY_SECONDS = 30 * 24 * 60 * 60 // 30 days\n\nexport function clientRegistrationHandler({\n  clientsStore,\n  clientSecretExpirySeconds = DEFAULT_CLIENT_SECRET_EXPIRY_SECONDS,\n  clientIdGeneration = true,\n}: ClientRegistrationHandlerOptions): MiddlewareHandler {\n  if (!clientsStore.registerClient) {\n    throw new Error('Client registration store does not support registering clients')\n  }\n\n  return async (c) => {\n    c.header('Cache-Control', 'no-store')\n\n    try {\n      const parseResult = OAuthClientMetadataSchema.safeParse(await c.req.json())\n      if (!parseResult.success) {\n        throw new InvalidClientMetadataError(parseResult.error.message)\n      }\n\n      const clientMetadata = parseResult.data\n      const isPublicClient = clientMetadata.token_endpoint_auth_method === 'none'\n\n      // Generate client credentials\n      const clientSecret = isPublicClient ? undefined : genRanHex(64)\n      const clientIdIssuedAt = Math.floor(Date.now() / 1000)\n\n      // Calculate client secret expiry time\n      const clientsDoExpire = clientSecretExpirySeconds > 0\n      const secretExpiryTime = clientsDoExpire ? clientIdIssuedAt + clientSecretExpirySeconds : 0\n      const clientSecretExpiresAt = isPublicClient ? undefined : secretExpiryTime\n\n      let clientInfo: Omit<OAuthClientInformationFull, 'client_id'> & { client_id?: string } = {\n        ...clientMetadata,\n        client_secret: clientSecret,\n        client_secret_expires_at: clientSecretExpiresAt,\n      }\n\n      if (clientIdGeneration) {\n        clientInfo.client_id = crypto.randomUUID()\n        clientInfo.client_id_issued_at = clientIdIssuedAt\n      }\n\n      clientInfo = await clientsStore.registerClient!(clientInfo)\n      return c.json(clientInfo, 201)\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400\n        return c.json(error.toResponseObject(), status)\n      } else {\n        const serverError = new ServerError('Internal Server Error')\n        return c.json(serverError.toResponseObject(), 500)\n      }\n    }\n  }\n}\n\nconst genRanHex = (size: number) =>\n  [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join('')\n","import {\n  InvalidRequestError,\n  OAuthError,\n  ServerError,\n} from '@modelcontextprotocol/sdk/server/auth/errors.js'\nimport type { OAuthServerProvider } from '@modelcontextprotocol/sdk/server/auth/provider.js'\nimport { OAuthTokenRevocationRequestSchema } from '@modelcontextprotocol/sdk/shared/auth.js'\nimport type { MiddlewareHandler } from 'hono'\nimport type { ClientAuthenticationEnv } from '../middleware/client-auth'\n\nexport function revokeHandler(\n  provider: OAuthServerProvider\n): MiddlewareHandler<ClientAuthenticationEnv> {\n  if (!provider.revokeToken) {\n    throw new Error('Auth provider does not support revoking tokens')\n  }\n\n  return async (c) => {\n    c.header('Cache-Control', 'no-store')\n\n    try {\n      const parseResult = OAuthTokenRevocationRequestSchema.safeParse(await c.req.json())\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message)\n      }\n\n      const client = c.get('client')\n      if (!client) {\n        // This should never happen\n        throw new ServerError('Internal Server Error')\n      }\n\n      await provider.revokeToken!(client, parseResult.data)\n      return c.json({})\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400\n        return c.json(error.toResponseObject(), status)\n      } else {\n        const serverError = new ServerError('Internal Server Error')\n        return c.json(serverError.toResponseObject(), 500)\n      }\n    }\n  }\n}\n","import {\n  InvalidGrantError,\n  InvalidRequestError,\n  OAuthError,\n  ServerError,\n  UnsupportedGrantTypeError,\n} from '@modelcontextprotocol/sdk/server/auth/errors.js'\nimport type { OAuthServerProvider } from '@modelcontextprotocol/sdk/server/auth/provider.js'\nimport type { MiddlewareHandler } from 'hono'\nimport { verifyChallenge } from 'pkce-challenge'\nimport * as z from 'zod/v4'\nimport type { ClientAuthenticationEnv } from '../middleware/client-auth'\n\nconst TokenRequestSchema = z.object({\n  grant_type: z.string(),\n})\n\nconst AuthorizationCodeGrantSchema = z.object({\n  code: z.string(),\n  code_verifier: z.string(),\n  redirect_uri: z.string().optional(),\n  resource: z.url().optional(),\n})\n\nconst RefreshTokenGrantSchema = z.object({\n  refresh_token: z.string(),\n  scope: z.string().optional(),\n  resource: z.url().optional(),\n})\n\nexport function tokenHandler(\n  provider: OAuthServerProvider\n): MiddlewareHandler<ClientAuthenticationEnv> {\n  return async (c) => {\n    c.header('Cache-Control', 'no-store')\n\n    try {\n      let body: any\n\n      if (c.req.header('Content-Type') === 'application/json') {\n        body = await c.req.json()\n      } else {\n        body = await c.req.parseBody()\n      }\n\n      const parseResult = TokenRequestSchema.safeParse(body)\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message)\n      }\n\n      const { grant_type } = parseResult.data\n\n      const client = c.get('client')\n      if (!client) {\n        // This should never happen\n        throw new ServerError('Internal Server Error')\n      }\n\n      switch (grant_type) {\n        case 'authorization_code': {\n          const parseResult = AuthorizationCodeGrantSchema.safeParse(body)\n          if (!parseResult.success) {\n            throw new InvalidRequestError(parseResult.error.message)\n          }\n\n          const { code, code_verifier, redirect_uri, resource } = parseResult.data\n\n          const skipLocalPkceValidation = provider.skipLocalPkceValidation\n\n          // Perform local PKCE validation unless explicitly skipped\n          // (e.g. to validate code_verifier in upstream server)\n          if (!skipLocalPkceValidation) {\n            const codeChallenge = await provider.challengeForAuthorizationCode(client, code)\n            if (!(await verifyChallenge(code_verifier, codeChallenge))) {\n              throw new InvalidGrantError('code_verifier does not match the challenge')\n            }\n          }\n\n          // Passes the code_verifier to the provider if PKCE validation didn't occur locally\n          const tokens = await provider.exchangeAuthorizationCode(\n            client,\n            code,\n            skipLocalPkceValidation ? code_verifier : undefined,\n            redirect_uri,\n            resource ? new URL(resource) : undefined\n          )\n          return c.json(tokens, 200)\n        }\n\n        case 'refresh_token': {\n          const parseResult = RefreshTokenGrantSchema.safeParse(body)\n          if (!parseResult.success) {\n            throw new InvalidRequestError(parseResult.error.message)\n          }\n\n          const { refresh_token, scope, resource } = parseResult.data\n\n          const scopes = scope?.split(' ')\n          const tokens = await provider.exchangeRefreshToken(\n            client,\n            refresh_token,\n            scopes,\n            resource ? new URL(resource) : undefined\n          )\n          return c.json(tokens)\n        }\n\n        // Not supported right now\n        //case \"client_credentials\":\n\n        default:\n          throw new UnsupportedGrantTypeError(\n            'The grant type is not supported by this authorization server.'\n          )\n      }\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400\n        return c.json(error.toResponseObject(), status)\n      }\n\n      const serverError = new ServerError('Internal Server Error')\n      return c.json(serverError.toResponseObject(), 500)\n    }\n  }\n}\n","export const checkIssuerUrl = (issuer: URL): void => {\n  // Technically RFC 8414 does not permit a localhost HTTPS exemption, but this will be necessary for ease of testing\n  if (\n    issuer.protocol !== 'https:' &&\n    issuer.hostname !== 'localhost' &&\n    issuer.hostname !== '127.0.0.1'\n  ) {\n    throw new Error('Issuer URL must be HTTPS')\n  }\n  if (issuer.hash) {\n    throw new Error(`Issuer URL must not have a fragment: ${issuer}`)\n  }\n  if (issuer.search) {\n    throw new Error(`Issuer URL must not have a query string: ${issuer}`)\n  }\n}\n","import type {\n  OAuthMetadata,\n  OAuthProtectedResourceMetadata,\n} from '@modelcontextprotocol/sdk/shared/auth.js'\nimport type { Env, Schema } from 'hono'\nimport { Hono } from 'hono'\nimport { checkIssuerUrl } from './utils'\n\nexport type WellKnownRouterOptions = {\n  /**\n   * OAuth Metadata as would be returned from the authorization server\n   * this MCP server relies on\n   */\n  oauthMetadata: OAuthMetadata\n\n  /**\n   * The url of the MCP server, for use in protected resource metadata\n   */\n  resourceServerUrl: URL\n\n  /**\n   * The url for documentation for the MCP server\n   */\n  serviceDocumentationUrl?: URL\n\n  /**\n   * An optional list of scopes supported by this MCP server\n   */\n  scopesSupported?: string[]\n\n  /**\n   * An optional resource name to display in resource metadata\n   */\n  resourceName?: string\n}\n\nexport function wellKnownRouter<E extends Env, S extends Schema, P extends string>(\n  options: WellKnownRouterOptions\n): Hono<E, S, P> {\n  checkIssuerUrl(new URL(options.oauthMetadata.issuer))\n\n  const router = new Hono<E, S, P>().basePath('/.well-known')\n\n  const protectedResourceMetadata: OAuthProtectedResourceMetadata = {\n    resource: options.resourceServerUrl.href,\n\n    authorization_servers: [options.oauthMetadata.issuer],\n\n    scopes_supported: options.scopesSupported,\n    resource_name: options.resourceName,\n    resource_documentation: options.serviceDocumentationUrl?.href,\n  }\n\n  // Serve PRM at the path-specific URL per RFC 9728\n  const rsPath = new URL(options.resourceServerUrl.href).pathname\n  router.get(`/oauth-protected-resource${rsPath === '/' ? '' : rsPath}`, (c) =>\n    c.json(protectedResourceMetadata)\n  )\n\n  // Always add this for backwards compatibility\n  router.get('/oauth-authorization-server', (c) => c.json(options.oauthMetadata))\n\n  return router\n}\n","import type { OAuthRegisteredClientsStore } from '@modelcontextprotocol/sdk/server/auth/clients.js'\nimport {\n  InvalidClientError,\n  InvalidRequestError,\n  OAuthError,\n  ServerError,\n} from '@modelcontextprotocol/sdk/server/auth/errors.js'\nimport type { OAuthClientInformationFull } from '@modelcontextprotocol/sdk/shared/auth.js'\nimport type { MiddlewareHandler } from 'hono'\nimport * as z from 'zod/v4'\n\nexport type ClientAuthenticationMiddlewareOptions = {\n  /**\n   * A store used to read information about registered OAuth clients.\n   */\n  clientsStore: OAuthRegisteredClientsStore\n}\n\nconst ClientAuthenticatedRequestSchema = z.object({\n  client_id: z.string(),\n  client_secret: z.string().optional(),\n})\n\nexport type ClientAuthenticationEnv = {\n  Variables: {\n    /**\n     * The authenticated client for this request, if the `authenticateClient` middleware was used.\n     */\n    client: OAuthClientInformationFull\n  }\n}\n\nexport function authenticateClient({\n  clientsStore,\n}: ClientAuthenticationMiddlewareOptions): MiddlewareHandler<ClientAuthenticationEnv> {\n  return async (c, next) => {\n    try {\n      let body: any\n\n      if (c.req.header('Content-Type') === 'application/json') {\n        body = await c.req.json()\n      } else {\n        body = await c.req.parseBody()\n      }\n\n      const result = ClientAuthenticatedRequestSchema.safeParse(body)\n\n      if (!result.success) {\n        throw new InvalidRequestError(String(result.error))\n      }\n\n      const { client_id, client_secret } = result.data\n      const client = await clientsStore.getClient(client_id)\n      if (!client) {\n        throw new InvalidClientError('Invalid client_id')\n      }\n\n      // If client has a secret, validate it\n      if (client.client_secret) {\n        // Check if client_secret is required but not provided\n        if (!client_secret) {\n          throw new InvalidClientError('Client secret is required')\n        }\n\n        // Check if client_secret matches\n        if (client.client_secret !== client_secret) {\n          throw new InvalidClientError('Invalid client_secret')\n        }\n\n        // Check if client_secret has expired\n        if (\n          client.client_secret_expires_at &&\n          client.client_secret_expires_at < Math.floor(Date.now() / 1000)\n        ) {\n          throw new InvalidClientError('Client secret has expired')\n        }\n      }\n\n      c.set('client', client)\n\n      await next()\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400\n        return c.json(error.toResponseObject(), status)\n      }\n\n      const serverError = new ServerError('Internal Server Error')\n      return c.json(serverError.toResponseObject(), 500)\n    }\n  }\n}\n","import { TooManyRequestsError } from '@modelcontextprotocol/sdk/server/auth/errors.js'\nimport type { OAuthServerProvider } from '@modelcontextprotocol/sdk/server/auth/provider.js'\nimport type { OAuthMetadata } from '@modelcontextprotocol/sdk/shared/auth.js'\nimport type { Env, MiddlewareHandler, Schema } from 'hono'\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport type { ConfigType as RateLimitOptions } from 'hono-rate-limiter'\nimport {\n  authorizeHandler,\n  checkIssuerUrl,\n  clientRegistrationHandler,\n  revokeHandler,\n  tokenHandler,\n  wellKnownRouter,\n} from './helpers'\nimport { authenticateClient } from './middleware/client-auth'\n\nexport type AuthRouterOptions = {\n  /**\n   * A provider implementing the actual authorization logic for this router.\n   */\n  provider: OAuthServerProvider\n\n  /**\n   * The authorization server's issuer identifier, which is a URL that uses the \"https\" scheme and has no query or fragment components.\n   */\n  issuerUrl: URL\n\n  /**\n   * The base URL of the authorization server to use for the metadata endpoints.\n   *\n   * If not provided, the issuer URL will be used as the base URL.\n   */\n  baseUrl?: URL\n\n  /**\n   * An optional URL of a page containing human-readable information that developers might want or need to know when using the authorization server.\n   */\n  serviceDocumentationUrl?: URL\n\n  /**\n   * An optional list of scopes supported by this authorization server\n   */\n  scopesSupported?: string[]\n\n  /**\n   * The resource name to be displayed in protected resource metadata\n   */\n  resourceName?: string\n\n  /**\n   * The URL of the protected resource (RS) whose metadata we advertise.\n   * If not provided, falls back to `baseUrl` and then to `issuerUrl` (AS=RS).\n   */\n  resourceServerUrl?: URL\n\n  // Individual options per route\n  authorizationOptions?: {\n    rateLimit?: Partial<RateLimitOptions> | false\n  }\n  clientRegistrationOptions?: {\n    rateLimit?: Partial<RateLimitOptions> | false\n    clientIdGeneration?: boolean\n    clientSecretExpirySeconds?: number\n  }\n  revocationOptions?: {\n    rateLimit?: Partial<RateLimitOptions> | false\n  }\n  tokenOptions?: {\n    rateLimit?: Partial<RateLimitOptions> | false\n  }\n}\n\nexport const createOAuthMetadata = (options: {\n  provider?: OAuthServerProvider\n  issuerUrl: URL\n  baseUrl?: URL\n  serviceDocumentationUrl?: URL\n  scopesSupported?: string[]\n}): OAuthMetadata => {\n  const issuer = options.issuerUrl\n  const baseUrl = options.baseUrl\n\n  checkIssuerUrl(issuer)\n\n  const authorization_endpoint = '/authorize'\n  const token_endpoint = '/token'\n  const registration_endpoint = options.provider?.clientsStore.registerClient\n    ? '/register'\n    : undefined\n  const revocation_endpoint = options.provider?.revokeToken ? '/revoke' : undefined\n\n  const metadata: OAuthMetadata = {\n    issuer: issuer.href,\n    service_documentation: options.serviceDocumentationUrl?.href,\n\n    authorization_endpoint: new URL(authorization_endpoint, baseUrl || issuer).href,\n    response_types_supported: ['code'],\n    code_challenge_methods_supported: ['S256'],\n\n    token_endpoint: new URL(token_endpoint, baseUrl || issuer).href,\n    token_endpoint_auth_methods_supported: ['client_secret_post'],\n    grant_types_supported: ['authorization_code', 'refresh_token'],\n\n    scopes_supported: options.scopesSupported,\n\n    revocation_endpoint: revocation_endpoint\n      ? new URL(revocation_endpoint, baseUrl || issuer).href\n      : undefined,\n    revocation_endpoint_auth_methods_supported: revocation_endpoint\n      ? ['client_secret_post']\n      : undefined,\n\n    registration_endpoint: registration_endpoint\n      ? new URL(registration_endpoint, baseUrl || issuer).href\n      : undefined,\n  }\n\n  return metadata\n}\n\n/**\n * Installs standard MCP authorization server endpoints, including dynamic client registration and token revocation (if supported).\n * Also advertises standard authorization server metadata, for easier discovery of supported configurations by clients.\n * Note: if your MCP server is only a resource server and not an authorization server, use mcpAuthMetadataRouter instead.\n *\n * By default, rate limiting is applied to all endpoints to prevent abuse.\n *\n * This router MUST be installed at the application root, like so:\n *\n *  const app = new Hono();\n *  app.route(\"/\", mcpAuthRouter(...));\n */\nexport function mcpAuthRouter<E extends Env, S extends Schema, P extends string>(\n  options: AuthRouterOptions\n): Hono<E, S, P> {\n  const oauthMetadata = createOAuthMetadata(options)\n\n  const router = new Hono<E, S, P>().use(cors())\n\n  router.on(\n    ['GET', 'POST'],\n    new URL(oauthMetadata.authorization_endpoint).pathname,\n    applyRateLimiter(options.authorizationOptions?.rateLimit, {\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      limit: 100, // 100 requests per windowMs\n      standardHeaders: true,\n      keyGenerator: () => 'some-unique-key',\n      message: new TooManyRequestsError(\n        'You have exceeded the rate limit for token requests'\n      ).toResponseObject(),\n    }),\n    authorizeHandler(options.provider)\n  )\n\n  const authenticateClientMiddleware = authenticateClient({\n    clientsStore: options.provider.clientsStore,\n  })\n\n  router.post(\n    new URL(oauthMetadata.token_endpoint).pathname,\n    applyRateLimiter(options.tokenOptions?.rateLimit, {\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      limit: 50, // 50 requests per windowMs\n      standardHeaders: true,\n      keyGenerator: () => 'some-unique-key',\n      message: new TooManyRequestsError(\n        'You have exceeded the rate limit for token requests'\n      ).toResponseObject(),\n    }),\n    authenticateClientMiddleware,\n    tokenHandler(options.provider)\n  )\n\n  router.route(\n    '/',\n    wellKnownRouter({\n      oauthMetadata,\n      // This router is used for AS+RS combo's, so the issuer is also the resource server\n      resourceServerUrl:\n        options.resourceServerUrl ?? options.baseUrl ?? new URL(oauthMetadata.issuer),\n      serviceDocumentationUrl: options.serviceDocumentationUrl,\n      scopesSupported: options.scopesSupported,\n      resourceName: options.resourceName,\n    })\n  )\n\n  if (oauthMetadata.registration_endpoint) {\n    router.post(\n      new URL(oauthMetadata.registration_endpoint).pathname,\n      applyRateLimiter(options.clientRegistrationOptions?.rateLimit, {\n        windowMs: 60 * 60 * 1000, // 1 hour\n        limit: 20, // 20 requests per windowMs\n        standardHeaders: true,\n        keyGenerator: () => 'some-unique-key',\n        message: new TooManyRequestsError(\n          'You have exceeded the rate limit for client registration requests'\n        ).toResponseObject(),\n      }),\n      clientRegistrationHandler({\n        clientsStore: options.provider.clientsStore,\n        clientIdGeneration: options.clientRegistrationOptions?.clientIdGeneration,\n        clientSecretExpirySeconds: options.clientRegistrationOptions?.clientSecretExpirySeconds,\n      })\n    )\n  }\n\n  if (oauthMetadata.revocation_endpoint) {\n    router.post(\n      new URL(oauthMetadata.revocation_endpoint).pathname,\n      applyRateLimiter(options.revocationOptions?.rateLimit, {\n        windowMs: 15 * 60 * 1000, // 15 minutes\n        limit: 50, // 50 requests per windowMs\n        standardHeaders: true,\n        keyGenerator: () => 'some-unique-key',\n        message: new TooManyRequestsError(\n          'You have exceeded the rate limit for token revocation requests'\n        ).toResponseObject(),\n      }),\n      authenticateClientMiddleware,\n      revokeHandler(options.provider)\n    )\n  }\n\n  return router as unknown as Hono<E, S, P>\n}\n\nfunction applyRateLimiter(\n  options: Partial<RateLimitOptions> | undefined | false,\n  defaultOptions: Partial<RateLimitOptions>\n): MiddlewareHandler {\n  if (options === false) {\n    return (_c, next) => next()\n  }\n\n  return async (c, next) => {\n    try {\n      const rateLimiter = await import('hono-rate-limiter').then((m) => m.rateLimiter)\n\n      return await rateLimiter({\n        ...defaultOptions,\n        ...options,\n      } as RateLimitOptions)(c, next)\n    } catch {\n      throw new Error('@hono/mcp: Missing dependencies \"hono-rate-limiter\".')\n    }\n  }\n}\n","import type { MiddlewareHandler } from 'hono'\nimport { bearerAuth as bearerAuthMiddleware } from 'hono/bearer-auth'\n\nexport const bearerAuth = (\n  options: Parameters<typeof bearerAuthMiddleware>[0]\n): MiddlewareHandler =>\n  bearerAuthMiddleware({\n    noAuthenticationHeader: {\n      wwwAuthenticateHeader: (c) =>\n        `Bearer error=\"Unauthorized\", error_description=\"Unauthorized\", resource_metadata=\"${new URL(c.req.url).origin}/.well-known/oauth-protected-resource\"`,\n    },\n    invalidAuthenticationHeader: {\n      wwwAuthenticateHeader: (c) =>\n        `Bearer error=\"Unauthorized\", error_description=\"Unauthorized\", resource_metadata=\"${new URL(c.req.url).origin}/.well-known/oauth-protected-resource\"`,\n    },\n    ...options,\n  })\n","import type { OAuthRegisteredClientsStore } from '@modelcontextprotocol/sdk/server/auth/clients.js'\nimport { ServerError } from '@modelcontextprotocol/sdk/server/auth/errors.js'\nimport type {\n  AuthorizationParams,\n  OAuthServerProvider,\n} from '@modelcontextprotocol/sdk/server/auth/provider.js'\nimport type { AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js'\nimport type {\n  OAuthClientInformationFull,\n  OAuthTokenRevocationRequest,\n  OAuthTokens,\n} from '@modelcontextprotocol/sdk/shared/auth.js'\nimport {\n  OAuthClientInformationFullSchema,\n  OAuthTokensSchema,\n} from '@modelcontextprotocol/sdk/shared/auth.js'\nimport type { FetchLike } from '@modelcontextprotocol/sdk/shared/transport.js'\nimport type { Context } from 'hono'\n\nexport type ProxyEndpoints = {\n  authorizationUrl: string\n  tokenUrl: string\n  revocationUrl?: string\n  registrationUrl?: string\n}\n\nexport type ProxyOptions = {\n  /**\n   * Individual endpoint URLs for proxying specific OAuth operations\n   */\n  endpoints: ProxyEndpoints\n\n  /**\n   * Function to verify access tokens and return auth info\n   */\n  verifyAccessToken: (token: string) => Promise<AuthInfo>\n\n  /**\n   * Function to fetch client information from the upstream server\n   */\n  getClient: (clientId: string) => Promise<OAuthClientInformationFull | undefined>\n\n  /**\n   * Custom fetch implementation used for all network requests.\n   */\n  fetch?: FetchLike\n}\n\n/**\n * Implements an OAuth server that proxies requests to another OAuth server.\n */\nexport class ProxyOAuthServerProvider implements OAuthServerProvider {\n  protected readonly _endpoints: ProxyEndpoints\n  protected readonly _verifyAccessToken: (token: string) => Promise<AuthInfo>\n  protected readonly _getClient: (\n    clientId: string\n  ) => Promise<OAuthClientInformationFull | undefined>\n  protected readonly _fetch?: FetchLike\n\n  skipLocalPkceValidation = true\n\n  revokeToken?: (\n    client: OAuthClientInformationFull,\n    request: OAuthTokenRevocationRequest\n  ) => Promise<void>\n\n  constructor(options: ProxyOptions) {\n    this._endpoints = options.endpoints\n    this._verifyAccessToken = options.verifyAccessToken\n    this._getClient = options.getClient\n    this._fetch = options.fetch\n    if (options.endpoints?.revocationUrl) {\n      this.revokeToken = async (\n        client: OAuthClientInformationFull,\n        request: OAuthTokenRevocationRequest\n      ) => {\n        const revocationUrl = this._endpoints.revocationUrl\n\n        if (!revocationUrl) {\n          throw new Error('No revocation endpoint configured')\n        }\n\n        const params = new URLSearchParams()\n        params.set('token', request.token)\n        params.set('client_id', client.client_id)\n        if (client.client_secret) {\n          params.set('client_secret', client.client_secret)\n        }\n        if (request.token_type_hint) {\n          params.set('token_type_hint', request.token_type_hint)\n        }\n\n        const response = await (this._fetch ?? fetch)(revocationUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n          },\n          body: params.toString(),\n        })\n\n        if (!response.ok) {\n          throw new ServerError(`Token revocation failed: ${response.status}`)\n        }\n      }\n    }\n  }\n\n  get clientsStore(): OAuthRegisteredClientsStore {\n    const registrationUrl = this._endpoints.registrationUrl\n    return {\n      getClient: this._getClient,\n      ...(registrationUrl && {\n        registerClient: async (client: OAuthClientInformationFull) => {\n          const response = await (this._fetch ?? fetch)(registrationUrl, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(client),\n          })\n\n          if (!response.ok) {\n            throw new ServerError(`Client registration failed: ${response.status}`)\n          }\n\n          const data = await response.json()\n          return OAuthClientInformationFullSchema.parse(data)\n        },\n      }),\n    }\n  }\n\n  async authorize(\n    client: OAuthClientInformationFull,\n    params: AuthorizationParams,\n    c: Context\n  ): Promise<void> {\n    // Start with required OAuth parameters\n    const targetUrl = new URL(this._endpoints.authorizationUrl)\n    const searchParams = new URLSearchParams({\n      client_id: client.client_id,\n      response_type: 'code',\n      redirect_uri: params.redirectUri,\n      code_challenge: params.codeChallenge,\n      code_challenge_method: 'S256',\n    })\n\n    // Add optional standard OAuth parameters\n    if (params.state) searchParams.set('state', params.state)\n    if (params.scopes?.length) searchParams.set('scope', params.scopes.join(' '))\n    if (params.resource) searchParams.set('resource', params.resource.href)\n\n    targetUrl.search = searchParams.toString()\n    c.res = c.redirect(targetUrl.toString())\n  }\n\n  async challengeForAuthorizationCode(\n    _client: OAuthClientInformationFull,\n    _authorizationCode: string\n  ): Promise<string> {\n    // In a proxy setup, we don't store the code challenge ourselves\n    // Instead, we proxy the token request and let the upstream server validate it\n    return ''\n  }\n\n  async exchangeAuthorizationCode(\n    client: OAuthClientInformationFull,\n    authorizationCode: string,\n    codeVerifier?: string,\n    redirectUri?: string,\n    resource?: URL\n  ): Promise<OAuthTokens> {\n    const params = new URLSearchParams({\n      grant_type: 'authorization_code',\n      client_id: client.client_id,\n      code: authorizationCode,\n    })\n\n    if (client.client_secret) {\n      params.append('client_secret', client.client_secret)\n    }\n\n    if (codeVerifier) {\n      params.append('code_verifier', codeVerifier)\n    }\n\n    if (redirectUri) {\n      params.append('redirect_uri', redirectUri)\n    }\n\n    if (resource) {\n      params.append('resource', resource.href)\n    }\n\n    const response = await (this._fetch ?? fetch)(this._endpoints.tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: params.toString(),\n    })\n\n    if (!response.ok) {\n      throw new ServerError(`Token exchange failed: ${response.status}`)\n    }\n\n    const data = await response.json()\n    return OAuthTokensSchema.parse(data)\n  }\n\n  async exchangeRefreshToken(\n    client: OAuthClientInformationFull,\n    refreshToken: string,\n    scopes?: string[],\n    resource?: URL\n  ): Promise<OAuthTokens> {\n    const params = new URLSearchParams({\n      grant_type: 'refresh_token',\n      client_id: client.client_id,\n      refresh_token: refreshToken,\n    })\n\n    if (client.client_secret) {\n      params.set('client_secret', client.client_secret)\n    }\n\n    if (scopes?.length) {\n      params.set('scope', scopes.join(' '))\n    }\n\n    if (resource) {\n      params.set('resource', resource.href)\n    }\n\n    const response = await (this._fetch ?? fetch)(this._endpoints.tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: params.toString(),\n    })\n\n    if (!response.ok) {\n      throw new ServerError(`Token refresh failed: ${response.status}`)\n    }\n\n    const data = await response.json()\n    return OAuthTokensSchema.parse(data)\n  }\n\n  async verifyAccessToken(token: string): Promise<AuthInfo> {\n    return this._verifyAccessToken(token)\n  }\n}\n","import type { Env, Hono, Schema } from 'hono'\nimport type { WellKnownRouterOptions } from './helpers'\nimport { wellKnownRouter } from './helpers'\nimport { createOAuthMetadata } from './router'\n\nexport type SimpleMcpAuthRouterOptions = {\n  issuer: string\n} & Omit<WellKnownRouterOptions, 'oauthMetadata'>\n\nexport function simpleMcpAuthRouter<E extends Env, S extends Schema, P extends string>(\n  options: SimpleMcpAuthRouterOptions\n): Hono<E, S, P> {\n  const { issuer, ...wellKnownOptions } = options\n\n  return wellKnownRouter({\n    oauthMetadata: createOAuthMetadata({\n      issuerUrl: new URL(issuer),\n      scopesSupported: wellKnownOptions.scopesSupported,\n      serviceDocumentationUrl: wellKnownOptions.serviceDocumentationUrl,\n    }),\n    ...wellKnownOptions,\n  })\n}\n"],"mappings":"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"}