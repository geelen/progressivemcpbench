import { AuthorizationParams, OAuthServerProvider } from "@modelcontextprotocol/sdk/server/auth/provider.js";
import { OAuthClientInformationFull, OAuthMetadata, OAuthTokenRevocationRequest, OAuthTokens } from "@modelcontextprotocol/sdk/shared/auth.js";
import { Context, Env, Hono, MiddlewareHandler, Schema } from "hono";
import { ConfigType } from "hono-rate-limiter";
import { OAuthRegisteredClientsStore } from "@modelcontextprotocol/sdk/server/auth/clients.js";
import { bearerAuth } from "hono/bearer-auth";
import { AuthInfo } from "@modelcontextprotocol/sdk/server/auth/types.js";
import { FetchLike } from "@modelcontextprotocol/sdk/shared/transport.js";

//#region src/auth/router.d.ts
type AuthRouterOptions = {
  /**
  * A provider implementing the actual authorization logic for this router.
  */
  provider: OAuthServerProvider;
  /**
  * The authorization server's issuer identifier, which is a URL that uses the "https" scheme and has no query or fragment components.
  */
  issuerUrl: URL;
  /**
  * The base URL of the authorization server to use for the metadata endpoints.
  *
  * If not provided, the issuer URL will be used as the base URL.
  */
  baseUrl?: URL;
  /**
  * An optional URL of a page containing human-readable information that developers might want or need to know when using the authorization server.
  */
  serviceDocumentationUrl?: URL;
  /**
  * An optional list of scopes supported by this authorization server
  */
  scopesSupported?: string[];
  /**
  * The resource name to be displayed in protected resource metadata
  */
  resourceName?: string;
  /**
  * The URL of the protected resource (RS) whose metadata we advertise.
  * If not provided, falls back to `baseUrl` and then to `issuerUrl` (AS=RS).
  */
  resourceServerUrl?: URL;
  authorizationOptions?: {
    rateLimit?: Partial<ConfigType> | false;
  };
  clientRegistrationOptions?: {
    rateLimit?: Partial<ConfigType> | false;
    clientIdGeneration?: boolean;
    clientSecretExpirySeconds?: number;
  };
  revocationOptions?: {
    rateLimit?: Partial<ConfigType> | false;
  };
  tokenOptions?: {
    rateLimit?: Partial<ConfigType> | false;
  };
};
declare const createOAuthMetadata: (options: {
  provider?: OAuthServerProvider;
  issuerUrl: URL;
  baseUrl?: URL;
  serviceDocumentationUrl?: URL;
  scopesSupported?: string[];
}) => OAuthMetadata;
/**
* Installs standard MCP authorization server endpoints, including dynamic client registration and token revocation (if supported).
* Also advertises standard authorization server metadata, for easier discovery of supported configurations by clients.
* Note: if your MCP server is only a resource server and not an authorization server, use mcpAuthMetadataRouter instead.
*
* By default, rate limiting is applied to all endpoints to prevent abuse.
*
* This router MUST be installed at the application root, like so:
*
*  const app = new Hono();
*  app.route("/", mcpAuthRouter(...));
*/
declare function mcpAuthRouter<E extends Env, S extends Schema, P extends string>(options: AuthRouterOptions): Hono<E, S, P>;
//#endregion
//#region src/auth/helpers/authorize.d.ts
declare function authorizeHandler(provider: OAuthServerProvider): MiddlewareHandler;
//#endregion
//#region src/auth/helpers/register.d.ts
type ClientRegistrationHandlerOptions = {
  /**
  * A store used to save information about dynamically registered OAuth clients.
  */
  clientsStore: OAuthRegisteredClientsStore;
  /**
  * The number of seconds after which to expire issued client secrets, or 0 to prevent expiration of client secrets (not recommended).
  *
  * If not set, defaults to 30 days.
  */
  clientSecretExpirySeconds?: number;
  /**
  * Whether to generate a client ID before calling the client registration endpoint.
  *
  * If not set, defaults to true.
  */
  clientIdGeneration?: boolean;
};
declare function clientRegistrationHandler({
  clientsStore,
  clientSecretExpirySeconds,
  clientIdGeneration
}: ClientRegistrationHandlerOptions): MiddlewareHandler;
//#endregion
//#region src/auth/middleware/client-auth.d.ts
type ClientAuthenticationMiddlewareOptions = {
  /**
  * A store used to read information about registered OAuth clients.
  */
  clientsStore: OAuthRegisteredClientsStore;
};
type ClientAuthenticationEnv = {
  Variables: {
    /**
    * The authenticated client for this request, if the `authenticateClient` middleware was used.
    */
    client: OAuthClientInformationFull;
  };
};
declare function authenticateClient({
  clientsStore
}: ClientAuthenticationMiddlewareOptions): MiddlewareHandler<ClientAuthenticationEnv>;
//#endregion
//#region src/auth/helpers/revoke.d.ts
declare function revokeHandler(provider: OAuthServerProvider): MiddlewareHandler<ClientAuthenticationEnv>;
//#endregion
//#region src/auth/helpers/token.d.ts
declare function tokenHandler(provider: OAuthServerProvider): MiddlewareHandler<ClientAuthenticationEnv>;
//#endregion
//#region src/auth/helpers/utils.d.ts
declare const checkIssuerUrl: (issuer: URL) => void;
//#endregion
//#region src/auth/helpers/wellknown.d.ts
type WellKnownRouterOptions = {
  /**
  * OAuth Metadata as would be returned from the authorization server
  * this MCP server relies on
  */
  oauthMetadata: OAuthMetadata;
  /**
  * The url of the MCP server, for use in protected resource metadata
  */
  resourceServerUrl: URL;
  /**
  * The url for documentation for the MCP server
  */
  serviceDocumentationUrl?: URL;
  /**
  * An optional list of scopes supported by this MCP server
  */
  scopesSupported?: string[];
  /**
  * An optional resource name to display in resource metadata
  */
  resourceName?: string;
};
declare function wellKnownRouter<E extends Env, S extends Schema, P extends string>(options: WellKnownRouterOptions): Hono<E, S, P>;
//#endregion
//#region src/auth/middleware/bearerAuth.d.ts
declare const bearerAuth$1: (options: Parameters<typeof bearerAuth>[0]) => MiddlewareHandler;
//#endregion
//#region src/auth/providers/proxy-provider.d.ts
type ProxyEndpoints = {
  authorizationUrl: string;
  tokenUrl: string;
  revocationUrl?: string;
  registrationUrl?: string;
};
type ProxyOptions = {
  /**
  * Individual endpoint URLs for proxying specific OAuth operations
  */
  endpoints: ProxyEndpoints;
  /**
  * Function to verify access tokens and return auth info
  */
  verifyAccessToken: (token: string) => Promise<AuthInfo>;
  /**
  * Function to fetch client information from the upstream server
  */
  getClient: (clientId: string) => Promise<OAuthClientInformationFull | undefined>;
  /**
  * Custom fetch implementation used for all network requests.
  */
  fetch?: FetchLike;
};
/**
* Implements an OAuth server that proxies requests to another OAuth server.
*/
declare class ProxyOAuthServerProvider implements OAuthServerProvider {
  protected readonly _endpoints: ProxyEndpoints;
  protected readonly _verifyAccessToken: (token: string) => Promise<AuthInfo>;
  protected readonly _getClient: (clientId: string) => Promise<OAuthClientInformationFull | undefined>;
  protected readonly _fetch?: FetchLike;
  skipLocalPkceValidation: boolean;
  revokeToken?: (client: OAuthClientInformationFull, request: OAuthTokenRevocationRequest) => Promise<void>;
  constructor(options: ProxyOptions);
  get clientsStore(): OAuthRegisteredClientsStore;
  authorize(client: OAuthClientInformationFull, params: AuthorizationParams, c: Context): Promise<void>;
  challengeForAuthorizationCode(_client: OAuthClientInformationFull, _authorizationCode: string): Promise<string>;
  exchangeAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string, codeVerifier?: string, redirectUri?: string, resource?: URL): Promise<OAuthTokens>;
  exchangeRefreshToken(client: OAuthClientInformationFull, refreshToken: string, scopes?: string[], resource?: URL): Promise<OAuthTokens>;
  verifyAccessToken(token: string): Promise<AuthInfo>;
}
//#endregion
//#region src/auth/simpleAuth.d.ts
type SimpleMcpAuthRouterOptions = {
  issuer: string;
} & Omit<WellKnownRouterOptions, "oauthMetadata">;
declare function simpleMcpAuthRouter<E extends Env, S extends Schema, P extends string>(options: SimpleMcpAuthRouterOptions): Hono<E, S, P>;
//#endregion
export { authorizeHandler as _, ProxyOptions as a, mcpAuthRouter as b, wellKnownRouter as c, revokeHandler as d, ClientAuthenticationEnv as f, clientRegistrationHandler as g, ClientRegistrationHandlerOptions as h, ProxyOAuthServerProvider as i, checkIssuerUrl as l, authenticateClient as m, simpleMcpAuthRouter as n, bearerAuth$1 as o, ClientAuthenticationMiddlewareOptions as p, ProxyEndpoints as r, WellKnownRouterOptions as s, SimpleMcpAuthRouterOptions as t, tokenHandler as u, AuthRouterOptions as v, createOAuthMetadata as y };
//# sourceMappingURL=index-CyaxwnEU.d.cts.map